/* automatically generated by rust-bindgen 0.63.0 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const AC_INFINITE: i32 = -1;
pub const PFNC_Mono1p: u32 = 16842807;
pub const PFNC_Mono2p: u32 = 16908344;
pub const PFNC_Mono4p: u32 = 17039417;
pub const PFNC_Mono8: u32 = 17301505;
pub const PFNC_Mono8s: u32 = 17301506;
pub const PFNC_Mono10: u32 = 17825795;
pub const PFNC_Mono10p: u32 = 17432646;
pub const PFNC_Mono12: u32 = 17825797;
pub const PFNC_Mono12p: u32 = 17563719;
pub const PFNC_Mono14: u32 = 17825829;
pub const PFNC_Mono16: u32 = 17825799;
pub const PFNC_BayerBG8: u32 = 17301515;
pub const PFNC_BayerBG10: u32 = 17825807;
pub const PFNC_BayerBG10p: u32 = 17432658;
pub const PFNC_BayerBG12: u32 = 17825811;
pub const PFNC_BayerBG12p: u32 = 17563731;
pub const PFNC_BayerBG16: u32 = 17825841;
pub const PFNC_BayerGB8: u32 = 17301514;
pub const PFNC_BayerGB10: u32 = 17825806;
pub const PFNC_BayerGB10p: u32 = 17432660;
pub const PFNC_BayerGB12: u32 = 17825810;
pub const PFNC_BayerGB12p: u32 = 17563733;
pub const PFNC_BayerGB16: u32 = 17825840;
pub const PFNC_BayerGR8: u32 = 17301512;
pub const PFNC_BayerGR10: u32 = 17825804;
pub const PFNC_BayerGR10p: u32 = 17432662;
pub const PFNC_BayerGR12: u32 = 17825808;
pub const PFNC_BayerGR12p: u32 = 17563735;
pub const PFNC_BayerGR16: u32 = 17825838;
pub const PFNC_BayerRG8: u32 = 17301513;
pub const PFNC_BayerRG10: u32 = 17825805;
pub const PFNC_BayerRG10p: u32 = 17432664;
pub const PFNC_BayerRG12: u32 = 17825809;
pub const PFNC_BayerRG12p: u32 = 17563737;
pub const PFNC_BayerRG16: u32 = 17825839;
pub const PFNC_RGBa8: u32 = 35651606;
pub const PFNC_RGBa10: u32 = 37748831;
pub const PFNC_RGBa10p: u32 = 36175968;
pub const PFNC_RGBa12: u32 = 37748833;
pub const PFNC_RGBa12p: u32 = 36700258;
pub const PFNC_RGBa14: u32 = 37748835;
pub const PFNC_RGBa16: u32 = 37748836;
pub const PFNC_RGB8: u32 = 35127316;
pub const PFNC_RGB8_Planar: u32 = 35127329;
pub const PFNC_RGB10: u32 = 36700184;
pub const PFNC_RGB10_Planar: u32 = 36700194;
pub const PFNC_RGB10p: u32 = 35520604;
pub const PFNC_RGB10p32: u32 = 35651613;
pub const PFNC_RGB12: u32 = 36700186;
pub const PFNC_RGB12_Planar: u32 = 36700195;
pub const PFNC_RGB12p: u32 = 35913821;
pub const PFNC_RGB14: u32 = 36700254;
pub const PFNC_RGB16: u32 = 36700211;
pub const PFNC_RGB16_Planar: u32 = 36700196;
pub const PFNC_RGB565p: u32 = 34603061;
pub const PFNC_BGRa8: u32 = 35651607;
pub const PFNC_BGRa10: u32 = 37748812;
pub const PFNC_BGRa10p: u32 = 36175949;
pub const PFNC_BGRa12: u32 = 37748814;
pub const PFNC_BGRa12p: u32 = 36700239;
pub const PFNC_BGRa14: u32 = 37748816;
pub const PFNC_BGRa16: u32 = 37748817;
pub const PFNC_BGR8: u32 = 35127317;
pub const PFNC_BGR10: u32 = 36700185;
pub const PFNC_BGR10p: u32 = 35520584;
pub const PFNC_BGR12: u32 = 36700187;
pub const PFNC_BGR12p: u32 = 35913801;
pub const PFNC_BGR14: u32 = 36700234;
pub const PFNC_BGR16: u32 = 36700235;
pub const PFNC_BGR565p: u32 = 34603062;
pub const PFNC_R8: u32 = 17301705;
pub const PFNC_R10: u32 = 17432778;
pub const PFNC_R12: u32 = 17563851;
pub const PFNC_R16: u32 = 17825996;
pub const PFNC_G8: u32 = 17301709;
pub const PFNC_G10: u32 = 17432782;
pub const PFNC_G12: u32 = 17563855;
pub const PFNC_G16: u32 = 17826000;
pub const PFNC_B8: u32 = 17301713;
pub const PFNC_B10: u32 = 17432786;
pub const PFNC_B12: u32 = 17563859;
pub const PFNC_B16: u32 = 17826004;
pub const PFNC_Coord3D_ABC8: u32 = 35127474;
pub const PFNC_Coord3D_ABC8_Planar: u32 = 35127475;
pub const PFNC_Coord3D_ABC10p: u32 = 35520731;
pub const PFNC_Coord3D_ABC10p_Planar: u32 = 35520732;
pub const PFNC_Coord3D_ABC12p: u32 = 35913950;
pub const PFNC_Coord3D_ABC12p_Planar: u32 = 35913951;
pub const PFNC_Coord3D_ABC16: u32 = 36700345;
pub const PFNC_Coord3D_ABC16_Planar: u32 = 36700346;
pub const PFNC_Coord3D_ABC32f: u32 = 39846080;
pub const PFNC_Coord3D_ABC32f_Planar: u32 = 39846081;
pub const PFNC_Coord3D_AC8: u32 = 34603188;
pub const PFNC_Coord3D_AC8_Planar: u32 = 34603189;
pub const PFNC_Coord3D_AC10p: u32 = 34865392;
pub const PFNC_Coord3D_AC10p_Planar: u32 = 34865393;
pub const PFNC_Coord3D_AC12p: u32 = 35127538;
pub const PFNC_Coord3D_AC12p_Planar: u32 = 35127539;
pub const PFNC_Coord3D_AC16: u32 = 35651771;
pub const PFNC_Coord3D_AC16_Planar: u32 = 35651772;
pub const PFNC_Coord3D_AC32f: u32 = 37748930;
pub const PFNC_Coord3D_AC32f_Planar: u32 = 37748931;
pub const PFNC_Coord3D_A8: u32 = 17301679;
pub const PFNC_Coord3D_A10p: u32 = 17432789;
pub const PFNC_Coord3D_A12p: u32 = 17563864;
pub const PFNC_Coord3D_A16: u32 = 17825974;
pub const PFNC_Coord3D_A32f: u32 = 18874557;
pub const PFNC_Coord3D_B8: u32 = 17301680;
pub const PFNC_Coord3D_B10p: u32 = 17432790;
pub const PFNC_Coord3D_B12p: u32 = 17563865;
pub const PFNC_Coord3D_B16: u32 = 17825975;
pub const PFNC_Coord3D_B32f: u32 = 18874558;
pub const PFNC_Coord3D_C8: u32 = 17301681;
pub const PFNC_Coord3D_C10p: u32 = 17432791;
pub const PFNC_Coord3D_C12p: u32 = 17563866;
pub const PFNC_Coord3D_C16: u32 = 17825976;
pub const PFNC_Coord3D_C32f: u32 = 18874559;
pub const PFNC_Confidence1: u32 = 17301700;
pub const PFNC_Confidence1p: u32 = 16842949;
pub const PFNC_Confidence8: u32 = 17301702;
pub const PFNC_Confidence16: u32 = 17825991;
pub const PFNC_Confidence32f: u32 = 18874568;
pub const PFNC_BiColorBGRG8: u32 = 34603174;
pub const PFNC_BiColorBGRG10: u32 = 35651753;
pub const PFNC_BiColorBGRG10p: u32 = 34865322;
pub const PFNC_BiColorBGRG12: u32 = 35651757;
pub const PFNC_BiColorBGRG12p: u32 = 35127470;
pub const PFNC_BiColorRGBG8: u32 = 34603173;
pub const PFNC_BiColorRGBG10: u32 = 35651751;
pub const PFNC_BiColorRGBG10p: u32 = 34865320;
pub const PFNC_BiColorRGBG12: u32 = 35651755;
pub const PFNC_BiColorRGBG12p: u32 = 35127468;
pub const PFNC_SCF1WBWG8: u32 = 17301607;
pub const PFNC_SCF1WBWG10: u32 = 17825896;
pub const PFNC_SCF1WBWG10p: u32 = 17432681;
pub const PFNC_SCF1WBWG12: u32 = 17825898;
pub const PFNC_SCF1WBWG12p: u32 = 17563755;
pub const PFNC_SCF1WBWG14: u32 = 17825900;
pub const PFNC_SCF1WBWG16: u32 = 17825901;
pub const PFNC_SCF1WGWB8: u32 = 17301614;
pub const PFNC_SCF1WGWB10: u32 = 17825903;
pub const PFNC_SCF1WGWB10p: u32 = 17432688;
pub const PFNC_SCF1WGWB12: u32 = 17825905;
pub const PFNC_SCF1WGWB12p: u32 = 17563762;
pub const PFNC_SCF1WGWB14: u32 = 17825907;
pub const PFNC_SCF1WGWB16: u32 = 17825908;
pub const PFNC_SCF1WGWR8: u32 = 17301621;
pub const PFNC_SCF1WGWR10: u32 = 17825910;
pub const PFNC_SCF1WGWR10p: u32 = 17432695;
pub const PFNC_SCF1WGWR12: u32 = 17825912;
pub const PFNC_SCF1WGWR12p: u32 = 17563769;
pub const PFNC_SCF1WGWR14: u32 = 17825914;
pub const PFNC_SCF1WGWR16: u32 = 17825915;
pub const PFNC_SCF1WRWG8: u32 = 17301628;
pub const PFNC_SCF1WRWG10: u32 = 17825917;
pub const PFNC_SCF1WRWG10p: u32 = 17432702;
pub const PFNC_SCF1WRWG12: u32 = 17825919;
pub const PFNC_SCF1WRWG12p: u32 = 17563776;
pub const PFNC_SCF1WRWG14: u32 = 17825921;
pub const PFNC_SCF1WRWG16: u32 = 17825922;
pub const PFNC_YCbCr8: u32 = 35127387;
pub const PFNC_YCbCr8_CbYCr: u32 = 35127354;
pub const PFNC_YCbCr10_CbYCr: u32 = 36700291;
pub const PFNC_YCbCr10p_CbYCr: u32 = 35520644;
pub const PFNC_YCbCr12_CbYCr: u32 = 36700293;
pub const PFNC_YCbCr12p_CbYCr: u32 = 35913862;
pub const PFNC_YCbCr411_8: u32 = 34340954;
pub const PFNC_YCbCr411_8_CbYYCrYY: u32 = 34340924;
pub const PFNC_YCbCr422_8: u32 = 34603067;
pub const PFNC_YCbCr422_8_CbYCrY: u32 = 34603075;
pub const PFNC_YCbCr422_10: u32 = 35651685;
pub const PFNC_YCbCr422_10_CbYCrY: u32 = 35651737;
pub const PFNC_YCbCr422_10p: u32 = 34865287;
pub const PFNC_YCbCr422_10p_CbYCrY: u32 = 34865306;
pub const PFNC_YCbCr422_12: u32 = 35651686;
pub const PFNC_YCbCr422_12_CbYCrY: u32 = 35651739;
pub const PFNC_YCbCr422_12p: u32 = 35127432;
pub const PFNC_YCbCr422_12p_CbYCrY: u32 = 35127452;
pub const PFNC_YCbCr601_8_CbYCr: u32 = 35127357;
pub const PFNC_YCbCr601_10_CbYCr: u32 = 36700297;
pub const PFNC_YCbCr601_10p_CbYCr: u32 = 35520650;
pub const PFNC_YCbCr601_12_CbYCr: u32 = 36700299;
pub const PFNC_YCbCr601_12p_CbYCr: u32 = 35913868;
pub const PFNC_YCbCr601_411_8_CbYYCrYY: u32 = 34340927;
pub const PFNC_YCbCr601_422_8: u32 = 34603070;
pub const PFNC_YCbCr601_422_8_CbYCrY: u32 = 34603076;
pub const PFNC_YCbCr601_422_10: u32 = 35651725;
pub const PFNC_YCbCr601_422_10_CbYCrY: u32 = 35651741;
pub const PFNC_YCbCr601_422_10p: u32 = 34865294;
pub const PFNC_YCbCr601_422_10p_CbYCrY: u32 = 34865310;
pub const PFNC_YCbCr601_422_12: u32 = 35651727;
pub const PFNC_YCbCr601_422_12_CbYCrY: u32 = 35651743;
pub const PFNC_YCbCr601_422_12p: u32 = 35127440;
pub const PFNC_YCbCr601_422_12p_CbYCrY: u32 = 35127456;
pub const PFNC_YCbCr709_8_CbYCr: u32 = 35127360;
pub const PFNC_YCbCr709_10_CbYCr: u32 = 36700305;
pub const PFNC_YCbCr709_10p_CbYCr: u32 = 35520658;
pub const PFNC_YCbCr709_12_CbYCr: u32 = 36700307;
pub const PFNC_YCbCr709_12p_CbYCr: u32 = 35913876;
pub const PFNC_YCbCr709_411_8_CbYYCrYY: u32 = 34340930;
pub const PFNC_YCbCr709_422_8: u32 = 34603073;
pub const PFNC_YCbCr709_422_8_CbYCrY: u32 = 34603077;
pub const PFNC_YCbCr709_422_10: u32 = 35651733;
pub const PFNC_YCbCr709_422_10_CbYCrY: u32 = 35651745;
pub const PFNC_YCbCr709_422_10p: u32 = 34865302;
pub const PFNC_YCbCr709_422_10p_CbYCrY: u32 = 34865314;
pub const PFNC_YCbCr709_422_12: u32 = 35651735;
pub const PFNC_YCbCr709_422_12_CbYCrY: u32 = 35651747;
pub const PFNC_YCbCr709_422_12p: u32 = 35127448;
pub const PFNC_YCbCr709_422_12p_CbYCrY: u32 = 35127460;
pub const PFNC_YCbCr2020_8_CbYCr: u32 = 35127540;
pub const PFNC_YCbCr2020_10_CbYCr: u32 = 36700405;
pub const PFNC_YCbCr2020_10p_CbYCr: u32 = 35520758;
pub const PFNC_YCbCr2020_12_CbYCr: u32 = 36700407;
pub const PFNC_YCbCr2020_12p_CbYCr: u32 = 35913976;
pub const PFNC_YCbCr2020_411_8_CbYYCrYY: u32 = 34341113;
pub const PFNC_YCbCr2020_422_8: u32 = 34603258;
pub const PFNC_YCbCr2020_422_8_CbYCrY: u32 = 34603259;
pub const PFNC_YCbCr2020_422_10: u32 = 35651836;
pub const PFNC_YCbCr2020_422_10_CbYCrY: u32 = 35651837;
pub const PFNC_YCbCr2020_422_10p: u32 = 34865406;
pub const PFNC_YCbCr2020_422_10p_CbYCrY: u32 = 34865407;
pub const PFNC_YCbCr2020_422_12: u32 = 35651840;
pub const PFNC_YCbCr2020_422_12_CbYCrY: u32 = 35651841;
pub const PFNC_YCbCr2020_422_12p: u32 = 35127554;
pub const PFNC_YCbCr2020_422_12p_CbYCrY: u32 = 35127555;
pub const PFNC_YUV8_UYV: u32 = 35127328;
pub const PFNC_YUV411_8_UYYVYY: u32 = 34340894;
pub const PFNC_YUV422_8: u32 = 34603058;
pub const PFNC_YUV422_8_UYVY: u32 = 34603039;
pub const GVSP_Mono10Packed: u32 = 17563652;
pub const GVSP_Mono12Packed: u32 = 17563654;
pub const GVSP_BayerBG10Packed: u32 = 17563689;
pub const GVSP_BayerBG12Packed: u32 = 17563693;
pub const GVSP_BayerGB10Packed: u32 = 17563688;
pub const GVSP_BayerGB12Packed: u32 = 17563692;
pub const GVSP_BayerGR10Packed: u32 = 17563686;
pub const GVSP_BayerGR12Packed: u32 = 17563690;
pub const GVSP_BayerRG10Packed: u32 = 17563687;
pub const GVSP_BayerRG12Packed: u32 = 17563691;
pub const GVSP_RGB10V1Packed: u32 = 35651612;
pub const GVSP_RGB12V1Packed: u32 = 35913780;
pub const LUCID_PolarizeMono8: u32 = 2164785153;
pub const LUCID_PolarizeMono12p: u32 = 2165047367;
pub const LUCID_PolarizeMono12Packed: u32 = 2165047302;
pub const LUCID_PolarizeMono12: u32 = 2165309448;
pub const LUCID_PolarizeMono16: u32 = 2165309447;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono8: u32 = 2183135247;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono12p: u32 = 2184183839;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_Mono16: u32 = 2185232431;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono8: u32 = 2182611007;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono12p: u32 = 2183397455;
pub const LUCID_PolarizedStokes_S0_S1_S2_Mono16: u32 = 2184183903;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono8: u32 = 2183135343;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono12p: u32 = 2184183935;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_Mono16: u32 = 2185232527;
pub const LUCID_PolarizedAolp_Mono8: u32 = 2164785375;
pub const LUCID_PolarizedAolp_Mono12p: u32 = 2165047535;
pub const LUCID_PolarizedDolp_Mono8: u32 = 2164785343;
pub const LUCID_PolarizedDolp_Mono12p: u32 = 2165047503;
pub const LUCID_PolarizedDolp_Mono16: u32 = 2853218986;
pub const LUCID_PolarizedDolpAolp_Mono8: u32 = 2182086815;
pub const LUCID_PolarizedDolpAolp_Mono12p: u32 = 2182611119;
pub const LUCID_Coord3D_ABCY16s: u32 = 2185233408;
pub const LUCID_Coord3D_ABC16s: u32 = 2184184833;
pub const LUCID_Coord3D_C16s: u32 = 2165310466;
pub const LUCID_Coord3D_ABCY16: u32 = 2185233411;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_BayerRG8: u32 = 2183135759;
pub const LUCID_PolarizedAngles_0d_45d_90d_135d_BayerRG12p: u32 = 2184184351;
pub const LUCID_PolarizedStokes_S0_S1_S2_BayerRG8: u32 = 2182611519;
pub const LUCID_PolarizedStokes_S0_S1_S2_BayerRG12p: u32 = 2183397967;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_BayerRG8: u32 = 2183135855;
pub const LUCID_PolarizedStokes_S0_S1_S2_S3_BayerRG12p: u32 = 2184184447;
pub const LUCID_PolarizedAolp_BayerRG8: u32 = 2164785887;
pub const LUCID_PolarizedAolp_BayerRG12p: u32 = 2165048047;
pub const LUCID_PolarizedDolp_BayerRG8: u32 = 2164785855;
pub const LUCID_PolarizedDolp_BayerRG12p: u32 = 2165048015;
pub const LUCID_PolarizedDolp_BayerRG16: u32 = 3138436027;
pub const LUCID_PolarizedDolpAolp_BayerRG8: u32 = 2182087327;
pub const LUCID_PolarizedDolpAolp_BayerRG12p: u32 = 2182611631;
pub const LUCID_Mono24: u32 = 2165835008;
pub const LUCID_BayerGR24: u32 = 2165835009;
pub const LUCID_BayerRG24: u32 = 2165835010;
pub const LUCID_BayerGB24: u32 = 2165835011;
pub const LUCID_BayerBG24: u32 = 2165835012;
pub const LUCID_RGB24: u32 = 2185757957;
pub const LUCID_BGR24: u32 = 2185757958;
pub const LUCID_YCbCr422_16_CbYCrY: u32 = 2183136519;
pub const LUCID_YCbCr422_24_CbYCrY: u32 = 2184185096;
pub const LUCID_YCbCr411_16_CbYYCrYY: u32 = 2182612233;
pub const LUCID_YCbCr411_24_CbYYCrYY: u32 = 2183398666;
pub const LUCID_PolarizedDolpAngle_Mono8: u32 = 2182086911;
pub const LUCID_PolarizedDolpAngle_Mono12p: u32 = 2182611215;
pub const LUCID_PolarizedDolpAngle_Mono16: u32 = 2183135519;
pub const LUCID_PolarizedDolpAngle_BayerRG8: u32 = 2182087423;
pub const LUCID_PolarizedDolpAngle_BayerRG12p: u32 = 2182611727;
pub const LUCID_PolarizedDolpAngle_BayerRG16: u32 = 2183136031;
pub const LUCID_Coord3D_C16Y8: u32 = 2182611972;
pub const LUCID_Coord3D_CY16: u32 = 2183136261;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " @typedef acSystem;\n\n Representation of the system object, the entry point into Arena SDK."]
pub type acSystem = *mut ::std::os::raw::c_void;
#[doc = " @typedef acDevice;\n\n Represents a device, used to configure and stream a device."]
pub type acDevice = *mut ::std::os::raw::c_void;
#[doc = " @typedef acBuffer;\n\n Represents a buffer, which carries a payload of either an image or a chunk\n data. A buffer can hold image data and/or chunk data."]
pub type acBuffer = *mut ::std::os::raw::c_void;
#[doc = " @typedef acFeatureStream;\n\n Represents a feature stream object, allowing node map configurations to be\n streamed to and from files."]
pub type acFeatureStream = *mut ::std::os::raw::c_void;
#[doc = " @typedef acNodeMap;\n\n Represents a node map, or feature tree."]
pub type acNodeMap = *mut ::std::os::raw::c_void;
#[doc = " @typedef acNode;\n\n Represents a node, or feature."]
pub type acNode = *mut ::std::os::raw::c_void;
#[doc = " @typedef acCallback;\n\n Represents a callback handle, used to deregister callbacks when they are no\n longer needed."]
pub type acCallback = *mut ::std::os::raw::c_void;
pub type bool8_t = u8;
#[doc = " @typedef acCallbackFunction\n\n The signature of a function needed to register a callback. An example of a\n function that could work might look something like the following.\n\n \\code{.c}\n \t// a function with the appropriate function signature to register as a callback\n \t// error handling skipped for brevity\n \t{\n \t\tvoid onCallback(acNode hNode, void* pUserData)\n \t\t{\n \t\t\tUserDataStruct* userData = reinterpret_cast<UserDataStruct*>(pUserData);\n\n \t\t\tchar pBuf[100];\n \t\t\tsize_t len = 100;\n \t\t\tacNodeGetName(hNode, pBuf, &len);\n \t\t\t// ...\n \t\t}\n \t}\n \\endcode"]
pub type acCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acNode, arg2: *mut ::std::os::raw::c_void)>;
pub type acImageCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acBuffer, arg2: *mut ::std::os::raw::c_void)>;
pub type acDeviceDisconnectCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg1: acDevice)>;
#[doc = "< Success, no error"]
pub const AC_ERROR_LIST_AC_ERR_SUCCESS: AC_ERROR_LIST = 0;
#[doc = "< Generic error"]
pub const AC_ERROR_LIST_AC_ERR_ERROR: AC_ERROR_LIST = -1001;
#[doc = "< Arena SDK not initialized"]
pub const AC_ERROR_LIST_AC_ERR_NOT_INITIALIZED: AC_ERROR_LIST = -1002;
#[doc = "< Function not implemented"]
pub const AC_ERROR_LIST_AC_ERR_NOT_IMPLEMENTED: AC_ERROR_LIST = -1003;
#[doc = "< Resource already in use"]
pub const AC_ERROR_LIST_AC_ERR_RESOURCE_IN_USE: AC_ERROR_LIST = -1004;
#[doc = "< Incorrect access"]
pub const AC_ERROR_LIST_AC_ERR_ACCESS_DENIED: AC_ERROR_LIST = -1005;
#[doc = "< Null/incorrect handle"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_HANDLE: AC_ERROR_LIST = -1006;
#[doc = "< Incorrect ID"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_ID: AC_ERROR_LIST = -1007;
#[doc = "< No data available"]
pub const AC_ERROR_LIST_AC_ERR_NO_DATA: AC_ERROR_LIST = -1008;
#[doc = "< Null/incorrect parameter"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_PARAMETER: AC_ERROR_LIST = -1009;
#[doc = "< Input/output error"]
pub const AC_ERROR_LIST_AC_ERR_IO: AC_ERROR_LIST = -1010;
#[doc = "< Timed out"]
pub const AC_ERROR_LIST_AC_ERR_TIMEOUT: AC_ERROR_LIST = -1011;
#[doc = "< Function aborted"]
pub const AC_ERROR_LIST_AC_ERR_ABORT: AC_ERROR_LIST = -1012;
#[doc = "< Invalid buffer"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_BUFFER: AC_ERROR_LIST = -1013;
#[doc = "< Function not available"]
pub const AC_ERROR_LIST_AC_ERR_NOT_AVAILABLE: AC_ERROR_LIST = -1014;
#[doc = "< Invalid register address"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_ADDRESS: AC_ERROR_LIST = -1015;
#[doc = "< Buffer too small"]
pub const AC_ERROR_LIST_AC_ERR_BUFFER_TOO_SMALL: AC_ERROR_LIST = -1016;
#[doc = "< Invalid index"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_INDEX: AC_ERROR_LIST = -1017;
#[doc = "< Error parsing chunk data"]
pub const AC_ERROR_LIST_AC_ERR_PARSING_CHUNK_DATA: AC_ERROR_LIST = -1018;
#[doc = "< Invalid value"]
pub const AC_ERROR_LIST_AC_ERR_INVALID_VALUE: AC_ERROR_LIST = -1019;
#[doc = "< Resource cannot perform more actions"]
pub const AC_ERROR_LIST_AC_ERR_RESOURCE_EXHAUSTED: AC_ERROR_LIST = -1020;
#[doc = "< Not enough memory"]
pub const AC_ERROR_LIST_AC_ERR_OUT_OF_MEMORY: AC_ERROR_LIST = -1021;
#[doc = "< Busy on anothe process"]
pub const AC_ERROR_LIST_AC_ERR_BUSY: AC_ERROR_LIST = -1022;
#[doc = "< Start adding custom error LIST here"]
pub const AC_ERROR_LIST_AC_ERR_CUSTOM: AC_ERROR_LIST = -10000;
#[doc = " @enum AC_ERROR_LIST\n\n This enum represents the different errors that a function might return.\n\n @warning\n  - Use AC_ERROR integer values in place of AC_ERROR_LIST enum values"]
pub type AC_ERROR_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_ERROR;\n\n Integer representation of the the error enum (AC_ERROR_LIST)."]
pub type AC_ERROR = i32;
#[doc = "< Not implemented"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_NI: AC_ACCESS_MODE_LIST = 0;
#[doc = "< Not available"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_NA: AC_ACCESS_MODE_LIST = 1;
#[doc = "< Write only"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_WO: AC_ACCESS_MODE_LIST = 2;
#[doc = "< Read only"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_RO: AC_ACCESS_MODE_LIST = 3;
#[doc = "< Read and write"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_RW: AC_ACCESS_MODE_LIST = 4;
#[doc = "< Undefined"]
pub const AC_ACCESS_MODE_LIST_AC_ACCESS_MODE_UNDEFINED: AC_ACCESS_MODE_LIST = 5;
#[doc = " @enum AC_ACCESS_MODE_LIST\n\n This enum represents the different access modes for a device or its features.\n\n @warning\n  - Use AC_ACCESS_MODE integer values in place of AC_ACCESS_MODE_LIST enum\n    values"]
pub type AC_ACCESS_MODE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_ACCESS_MODE;\n\n Integer representation of the access mode enum (AC_ACCESS_MODE_LIST)."]
pub type AC_ACCESS_MODE = i32;
#[doc = "< Do not use cache"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_NO_CACHE: AC_CACHING_MODE_LIST = 0;
#[doc = "< Write to cache and register"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_WRITE_THROUGH: AC_CACHING_MODE_LIST = 1;
#[doc = "< Write to register, write to cache on read"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_WRITE_AROUND: AC_CACHING_MODE_LIST = 2;
#[doc = "< Undefined"]
pub const AC_CACHING_MODE_LIST_AC_CACHING_MODE_UNDEFINED: AC_CACHING_MODE_LIST = 3;
#[doc = " @enum AC_CACHING_MODE_LIST\n\n This enum represents the different caching modes a node might use.\n\n @warning\n  - Use AC_CACHING_MODE integer values in place of AC_CACHING_MODE_LIST enum\n    values"]
pub type AC_CACHING_MODE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_CACHING_MODE;\n\n Integer representation of the caching mode enum (AC_CACHING_MODE_LIST)."]
pub type AC_CACHING_MODE = i32;
#[doc = "< Name resides in custom namespace"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_CUSTOM: AC_NAMESPACE_LIST = 0;
#[doc = "< Name resides in one of the standard namespaces"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_STANDARD: AC_NAMESPACE_LIST = 1;
#[doc = "< Undefined"]
pub const AC_NAMESPACE_LIST_AC_NAMESPACE_UNDEFINED: AC_NAMESPACE_LIST = 2;
#[doc = " @enum AC_NAMESPACE_LIST\n\n This enum represents whether a node is in the standard or custom namespaces.\n\n @warning\n  - Use AC_NAMESPACE integer values in place of AC_NAMESPACE_LIST enum values"]
pub type AC_NAMESPACE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_NAMESPACE;\n\n Integer representation of the namespace enum (AC_NAMESPACE_LIST)."]
pub type AC_NAMESPACE = i32;
#[doc = "< IValue interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_VALUE: AC_INTERFACE_TYPE_LIST = 0;
#[doc = "< IBase interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_BASE: AC_INTERFACE_TYPE_LIST = 1;
#[doc = "< IInteger interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_INTEGER: AC_INTERFACE_TYPE_LIST = 2;
#[doc = "< IBoolean interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_BOOLEAN: AC_INTERFACE_TYPE_LIST = 3;
#[doc = "< ICommand interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_COMMAND: AC_INTERFACE_TYPE_LIST = 4;
#[doc = "< IFloat interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_FLOAT: AC_INTERFACE_TYPE_LIST = 5;
#[doc = "< IString interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_STRING: AC_INTERFACE_TYPE_LIST = 6;
#[doc = "< IRegister interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_REGISTER: AC_INTERFACE_TYPE_LIST = 7;
#[doc = "< ICategory interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_CATEGORY: AC_INTERFACE_TYPE_LIST = 8;
#[doc = "< IEnumeration interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_ENUMERATION: AC_INTERFACE_TYPE_LIST = 9;
#[doc = "< IEnumEntry interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_ENUMENTRY: AC_INTERFACE_TYPE_LIST = 10;
#[doc = "< IPort interface"]
pub const AC_INTERFACE_TYPE_LIST_AC_INTERFACE_TYPE_PORT: AC_INTERFACE_TYPE_LIST = 11;
#[doc = " @enum AC_INTERFACE_TYPE_LIST\n\n This enum represents the interface type of a node.\n\n @warning\n  - Use AC_INTERFACE_TYPE integer values in place of AC_INTERFACE_LIST enum\n    values"]
pub type AC_INTERFACE_TYPE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_INTERFACE_TYPE;\n\n Integer representation of the interface type enum (AC_INTERFACE_TYPE_LIST)."]
pub type AC_INTERFACE_TYPE = i32;
#[doc = "< Always visible"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_BEGINNER: AC_VISIBILITY_LIST = 0;
#[doc = "< Visible for experts or gurus"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_EXPERT: AC_VISIBILITY_LIST = 1;
#[doc = "< Visible for gurus"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_GURU: AC_VISIBILITY_LIST = 2;
#[doc = "< Not visible"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_INVISIBLE: AC_VISIBILITY_LIST = 3;
#[doc = "< Undefined"]
pub const AC_VISIBILITY_LIST_AC_VISIBILITY_UNDEFINED: AC_VISIBILITY_LIST = 99;
#[doc = " @enum AC_VISIBILITY_LIST\n\n This enum represents the different visibilities of a node.\n\n @warning\n  - Use AC_VISIBILITY integer values in place of AC_VISIBILITY_LIST enum\n    values"]
pub type AC_VISIBILITY_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_VISIBILITY;\n\n Integer representation of the visibility enum (AC_VISIBILITY_LIST)."]
pub type AC_VISIBILITY = i32;
#[doc = "< The feature has no increment"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_NONE: AC_INC_MODE_LIST = 0;
#[doc = "< The feature has a fix increment"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_FIXED: AC_INC_MODE_LIST = 1;
#[doc = "< The feature has a list of valid values"]
pub const AC_INC_MODE_LIST_AC_INC_MODE_LIST: AC_INC_MODE_LIST = 2;
#[doc = " @enum AC_INC_MODE_LIST\n\n This enum represents the different increment modes of an integer/float node.\n\n @warning\n  - Use AC_INC_MODE integer values in place of AC_INC_MODE_LIST enum values"]
pub type AC_INC_MODE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_INC_MODE;\n\n Integer representation of the increment mode enum (AC_INC_MODE_LIST)."]
pub type AC_INC_MODE = i32;
#[doc = "< Slider with linear behavior"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_LINEAR: AC_REPRESENTATION_LIST = 0;
#[doc = "< Slider with logarithmic behavior"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_LOGARITHMIC: AC_REPRESENTATION_LIST = 1;
#[doc = "< Check box"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_BOOLEAN: AC_REPRESENTATION_LIST = 2;
#[doc = "< Decimal number in an edit control"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_PURE_NUMBER: AC_REPRESENTATION_LIST = 3;
#[doc = "< Hex number in an edit control"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_HEX_NUMBER: AC_REPRESENTATION_LIST = 4;
#[doc = "< IP address"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_IPV4_ADDRESS: AC_REPRESENTATION_LIST = 5;
#[doc = "< MAC address"]
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_MAC_ADDRESS: AC_REPRESENTATION_LIST = 6;
pub const AC_REPRESENTATION_LIST_AC_REPRESENTATION_UNDEFINED: AC_REPRESENTATION_LIST = 7;
#[doc = " @enum AC_REPRESENTATION_LIST\n\n This enum represents the different representations of an integer/float node.\n\n @warning\n  - Use AC_REPRESENTATION integer values in place of AC_REPRESENTATION_LIST\n    enum values"]
pub type AC_REPRESENTATION_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_REPRESENTATION;\n\n Integer representation of the numeric representation enum\n (AC_REPRESENTATION_LIST)."]
pub type AC_REPRESENTATION = i32;
#[doc = "< The notation if either scientific or fixed depending on what is shorter"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_AUTOMATIC: AC_DISPLAY_NOTATION_LIST = 0;
#[doc = "< The notation is fixed, e.g. 123.4"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_FIXED: AC_DISPLAY_NOTATION_LIST = 1;
#[doc = "< The notation is scientific, e.g. 1.234e2"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_SCIENTIFIC: AC_DISPLAY_NOTATION_LIST = 2;
#[doc = "< Undefined"]
pub const AC_DISPLAY_NOTATION_LIST_AC_DISPLAY_NOTATION_UNDEFINED: AC_DISPLAY_NOTATION_LIST = 3;
#[doc = " @enum AC_DISPLAY_NOTATION_LIST\n\n This enum represents the best way to display a float node.\n\n @warning\n  - Use AC_DISPLAY_NOTATION integer values in place of\n    AC_DISPLAY_NOTATION_LIST enum values"]
pub type AC_DISPLAY_NOTATION_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_DISPLAY_NOTATION;\n\n Integer representation of the display notation enum\n (AC_DISPLAY_NOTATION_LIST)."]
pub type AC_DISPLAY_NOTATION = i32;
#[doc = "< Image data only"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_IMAGE: AC_PAYLOAD_TYPE_LIST = 1;
#[doc = "< Image data extended with chunk data"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_IMAGE_EXTENDED_CHUNK: AC_PAYLOAD_TYPE_LIST = 16385;
#[doc = "< Chunk data only; image data may be present as chunk"]
pub const AC_PAYLOAD_TYPE_LIST_AC_PAYLOAD_TYPE_CHUNKDATA: AC_PAYLOAD_TYPE_LIST = 4;
#[doc = " @enum AC_PAYLOAD_TYPE_LIST\n\n This enum represents the different payload types of a buffer.\n\n @warning\n  - Use AC_PAYLOAD_TYPE integer values in place of AC_PAYLOAD_LIST enum\n    values"]
pub type AC_PAYLOAD_TYPE_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_PAYLOAD_TYPE;\n\n Integer representation of the payload type enum (AC_PAYLOAD_TYPE_LIST)."]
pub type AC_PAYLOAD_TYPE = i32;
#[doc = "< Unknown pixel endianness"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_UNKNOWN: AC_PIXEL_ENDIANNESS_LIST = 0;
#[doc = "< Little endian"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_LITTLE: AC_PIXEL_ENDIANNESS_LIST = 1;
#[doc = "< Big endian"]
pub const AC_PIXEL_ENDIANNESS_LIST_AC_PIXEL_ENDIANNESS_BIG: AC_PIXEL_ENDIANNESS_LIST = 2;
#[doc = " @enum AC_PIXEL_ENDIANNESS_LIST\n\n This enum represents the different pixel endiannesses.\n\n @warning\n  - Use AC_PIXEL_ENDIANNESS integer values in place of\n    AC_PIXEL_ENDIANNESS_LIST enum values"]
pub type AC_PIXEL_ENDIANNESS_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_PIXEL_ENDIANNESS;\n\n Integer representation of the pixel endianness enum\n (AC_PIXEL_ENDIANNESS_LIST)."]
pub type AC_PIXEL_ENDIANNESS = i32;
#[doc = "< Algorithm that averages nearest neighbours (faster)"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_DIRECTIONAL_INTERPOLATION:
    AC_BAYER_ALGORITHM_LIST = 0;
#[doc = "< Adaptive algorithm that uses directional data (slower, more accurate coloring)"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_ADAPTIVE_HOMOGENEITY_DIRECTED:
    AC_BAYER_ALGORITHM_LIST = 1;
#[doc = "< Undefined algorithm"]
pub const AC_BAYER_ALGORITHM_LIST_AC_BAYER_ALGORITHM_UNKNOWN: AC_BAYER_ALGORITHM_LIST = 2;
#[doc = " @enum AC_BAYER_ALGORITHM_LIST\n\n This enum represents the different algorithms available to interpolate bayer\n image data.\n\n @warning\n  - Use AC_BAYER_ALGORITHM integer values in place of AC_BAYER_ALGORITHM_LIST\n    enum values"]
pub type AC_BAYER_ALGORITHM_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_BAYER_ALGORITHM;\n\n Integer representation of the bayer algorithm enum\n (AC_BAYER_ALGORITHM_LIST)."]
pub type AC_BAYER_ALGORITHM = i32;
#[doc = "< default behaviour for the underlying transport layer"]
pub const AC_START_STREAM_FLAGS_LIST_AC_START_STREAM_FLAG_DEFAULT: AC_START_STREAM_FLAGS_LIST = 1;
#[doc = "< Will try to start Gvsp 2.0 stream with 16bit block id if supported"]
pub const AC_START_STREAM_FLAGS_LIST_AC_START_STREAM_FLAG_GVSP_LEGACY: AC_START_STREAM_FLAGS_LIST =
    1001;
#[doc = " @enum AC_START_STREAM_FLAGS_LIST\n\n This enum represents the transport layer flags for starting a stream."]
pub type AC_START_STREAM_FLAGS_LIST = ::std::os::raw::c_int;
#[doc = " @typedef AC_START_STREAM_FLAGS;\n\n Integer representation of the start stream flags\n (AC_START_STREAM_FLAGS_LIST)."]
pub type AC_START_STREAM_FLAGS = i32;
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acOpenSystem(acSystem* phSystem)\n\n @param phSystem\n  - Type: acSystem*\n  - [Out] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acOpenSystem </B> initializes the Arena SDK and retrieves the system\n object (acSystem). The system must be closed or memory will leak.\n\n @see\n  - acSystem"]
    pub fn acOpenSystem(phSystem: *mut acSystem) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCloseSystem(acSystem hSystem)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCloseSystem </B> cleans up the system (acSystem) and deinitializes the\n Arena SDK, deallocating all memory.\n\n @see\n  - acSystem"]
    pub fn acCloseSystem(hSystem: acSystem) -> AC_ERROR;
}
extern "C" {
    #[doc = " AC_ERROR acGetLastErrorMessage(char* pMessageBuf, size_t* pBufLen)\n\n @param pMessageBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetLastError </B> gets the most recent error from the current thread. If\n no errors have occurred in the thread, a \"No Error\" message is returned.\n"]
    pub fn acGetLastErrorMessage(
        pMessageBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acGetBitsPerPixel(uint64_t pixelFormat, size_t* pBitsPerPixel)\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to get bits per pixel\n\n @param pBitsPerPixel\n  - Type: size_t*\n  - [Out] parameter\n  - Number of bits per pixel for given pixel format\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetBitsPerPixel </B> get the number of bits per pixel of the image from\n the integer value of the pixel format (PfncFormat)."]
    pub fn acGetBitsPerPixel(pixelFormat: u64, pBitsPerPixel: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCalculateCRC32(const uint8_t* pData, size_t pDataLen, size_t* pCRCValue)\n\n @param pData\n  - Type: const uint8_t*\n  - [In] parameter\n  - A pointer to the data to use to calculate the CRC\n\n @param pDataLen\n  - Type: size_t\n  - [In] parameter\n  - The size of the data\n\n @param pCRCValue\n  - Type: size_t*\n  - [Out] parameter\n  - The calculated CRC value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCalculatedCRC32 </B> calculates a CRC value (cyclical redundancy check)\n on a dataset. This is used to check whether the dataset has been sent in its\n entirety."]
    pub fn acCalculateCRC32(pData: *const u8, pDataLen: usize, pCRCValue: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIsReadable(acNode hNode, bool8_t* pIsReadable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n\n @param pIsReadable\n  - Type: bool8_t*\n  - [Out] parameter\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIsReadable </B> checks whether a node is readable."]
    pub fn acIsReadable(hNode: acNode, pIsReadable: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIsWritable(acNode hNode, bool8_t* pIsWritable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n\n @param pIsWritable\n  - Type: bool8_t*\n  - [Out] parameter\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIsWritable </B> checks whether a node is writable."]
    pub fn acIsWritable(hNode: acNode, pIsWritable: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCalculateMaximumNumberOfBuffers(size_t payloadSize, size_t* pMaxBufs);\n\n @param payloadSize\n\t- Type: size_t\n\t- Unit: bytes\n\t- [In] parameter\n\t- Payload size of an image\n\n @param pMaxBufs\n\t- Type: size_t*\n\t- [Out] parameter\n\t- Maximum number of buffers\n\n @return\n\t- Type: AC_ERROR\n\t- Error code for the function\n\t- Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCalculateMaximumNumberOfBuffers </B> calculates the number of buffers it\n would take to fill 80% of the available memory."]
    pub fn acCalculateMaximumNumberOfBuffers(payloadSize: usize, pMaxBufs: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acGetVersion(char* pVersionBuf, size_t* pBufLen)\n\n @param pVersionBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acGetVersion </B> get build version"]
    pub fn acGetVersion(pVersionBuf: *mut ::std::os::raw::c_char, pBufLen: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetNumInterfaces(acSystem hSystem, size_t* pNumDevices)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pNumDevices\n  - Type: size_t*\n  - [Out] parameter\n  - The number of discovered interfaces\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetNumInterfaces </B> retrieves the number of discovered\n interfaces."]
    pub fn acSystemGetNumInterfaces(hSystem: acSystem, pNumDevices: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceIpAddress(acSystem hSystem, size_t index, uint32_t* pIpAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pIpAddress\n  - Type: uint32_t*\n  - [Out] parameter\n  - IP address as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceIpAddress </B> gets the IP address of a interface on\n the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceIpAddress(
        hSystem: acSystem,
        index: usize,
        pIpAddress: *mut u32,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceIpAddressStr(acSystem hSystem, size_t index, char* pIpAddressStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pIpAddressStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - IP address as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceIpAddressStr </B> gets the IP address of a interface\n on the network, returning it as a string."]
    pub fn acSystemGetInterfaceIpAddressStr(
        hSystem: acSystem,
        index: usize,
        pIpAddressStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceSubnetMask(acSystem hSystem, size_t index, uint32_t* pSubnetMask)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pSubnetMask\n  - Type: uint32_t*\n  - [Out] parameter\n  - Subnet mask as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceSubnetMask </B> gets the subnet mask of an interface\n on the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceSubnetMask(
        hSystem: acSystem,
        index: usize,
        pSubnetMask: *mut u32,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceSubnetMaskStr(acSystem hSystem, size_t index, char* pSubnetMaskStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pSubnetMaskStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Subnet mask as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceSubnetMaskStr </B> gets the subnet mask of an\n interface on the network, returning it as a string."]
    pub fn acSystemGetInterfaceSubnetMaskStr(
        hSystem: acSystem,
        index: usize,
        pSubnetMaskStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceMacAddress(acSystem hSystem, size_t index, uint64_t* pMacAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - MAC address as an integer\n\n @param pMacAddress\n  - Type: uint64_t*\n  - [Out] parameter\n  - MAC address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceMacAddress </B> gets the MAC address of a interface on\n the network, returning it as its raw integer value."]
    pub fn acSystemGetInterfaceMacAddress(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut u64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetInterfaceMacAddressStr(acSystem hSystem, size_t index, char* pMacAddress, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param pMacAddress\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - MAC address as a colon-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetInterfaceMacAddressStr </B> gets the MAC address of a interface\n on the network, returning it as a string."]
    pub fn acSystemGetInterfaceMacAddressStr(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevices(acSystem hSystem, uint64_t timeout)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevices </B> updates the internal list of devices, (along\n with their relevant interfaces). It must be called before retrieving the\n number of devices (acSystemGetNumDevices) or any time that an updated device\n list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevices(hSystem: acSystem, timeout: u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevicesHasChanged(acSystem hSystem, uint64_t timeout, bool8_t* pHasChanged)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @param pHasChanged\n  - Type: bool8_t*\n  - [Out] parameter\n  - True on first call that a device is found\n  - True if the device list has changed since the last call\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevicesHasChanged </B> updates the internal list of devices,\n (along with their relevant interfaces). It must be called before retrieving\n the number of devices (acSystemGetNumDevices) or any time that an updated\n device list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevicesHasChanged(
        hSystem: acSystem,
        timeout: u64,
        pHasChanged: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemUpdateDevicesOnInterface(acSystem hSystem, size_t interfaceIndex, uint64_t timeout, bool8_t* pHasChanged)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param interfaceIndex\n  - Type: size_t\n  - [In] parameter\n  - Index of the interface\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Time to wait for connected devices to respond\n\n @param pHasChanged\n  - Type: bool8_t*\n  - [Out] parameter\n  - True on first call that a device is found\n  - True if the device list has changed since the last call\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemUpdateDevicesOnInterface </B> updates the internal list of\n devices, (along with their relevant interfaces). It must be called before\n retrieving the number of devices (acSystemGetNumDevices) or any time that an\n updated device list might be necessary.\n\n @see\n  - acSystemGetNumDevices"]
    pub fn acSystemUpdateDevicesOnInterface(
        hSystem: acSystem,
        interfaceIndex: usize,
        timeout: u64,
        pHasChanged: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemAddUnicastDiscoveryDevice(acSystem hSystem, char* pUnicastDeviceIP)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pUnicastDeviceIP\n  - Type: char*\n  - [In] parameter\n  - A pointer to a string containing an iP Address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemAddUnicastDiscoveryDevice </B> registers an IP address for a device on a\n different subnet than the host. Registered devices will be enumerated\n using unicast discovery messages. The list of remote devices will\n persist until they are removed using RemoveUnicastDiscoveryDevice() or until\n the application terminates. Unicast discovery's will be sent when\n UpdateDevices() is called.\n\n @see\n  - acSystemRemoveUnicastDiscoveryDevice"]
    pub fn acSystemAddUnicastDiscoveryDevice(
        hSystem: acSystem,
        pUnicastDeviceIP: *mut ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemRemoveUnicastDiscoveryDevice(acSystem hSystem, char* pUnicastDeviceIP)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pUnicastDeviceIP\n  - Type: char*\n  - [In] parameter\n  - A pointer to a string containing an iP Address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemRemoveUnicastDiscoveryDevice </B> unregisters an IP address for a device on a\n different subnet than the host. To remove all registered devices,\n pass NULL for the IP address argument.\n\n @see\n  - acSystemRemoveUnicastDiscoveryDevice"]
    pub fn acSystemRemoveUnicastDiscoveryDevice(
        hSystem: acSystem,
        pUnicastDeviceIP: *mut ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetNumDevices(acSystem hSystem, size_t* pNumDevices)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param pNumDevices\n  - Type: size_t*\n  - [Out] parameter\n  - The number of discovered devices\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetNumDevices </B> retrieves the number of discovered devices. It\n must be called after updating the internal list of devices\n (acSystemUpdateDevices).\n\n @see\n  - acSystemUpdateDevices"]
    pub fn acSystemGetNumDevices(hSystem: acSystem, pNumDevices: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceModel(acSystem hSystem, size_t index, char* pModelNameBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pModelNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Model name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceModel </B> gets the model name of a device."]
    pub fn acSystemGetDeviceModel(
        hSystem: acSystem,
        index: usize,
        pModelNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceVendor(acSystem hSystem, size_t index, char* pVendorNameBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pVendorNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Vendor name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceVendor </B> gets the vendor/manufacturer name of a\n device. Vendor names differentiate between device vendors/manufacturers. Lucid\n devices return 'Lucid Vision Labs'."]
    pub fn acSystemGetDeviceVendor(
        hSystem: acSystem,
        index: usize,
        pVendorNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSerial(acSystem hSystem, size_t index, char* pSerialNumberBuf, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSerialNumberBuf\n  - Type: char*\n  - [Out] parameter\n  - Serial number of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetDeviceSerial </B> gets the serial number of a device. A serial\n number differentiates between devices. Each Lucid device has a unique serial\n number. Lucid serial numbers are numeric, but the serial numbers of other\n vendors may be alphanumeric."]
    pub fn acSystemGetDeviceSerial(
        hSystem: acSystem,
        index: usize,
        pSerialNumberBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceIpAddress(acSystem hSystem, size_t index, uint32_t* pIpAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIpAddress\n  - Type: uint32_t*\n  - [Out] parameter\n  - IP address as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceIpAddress </B> gets the IP address of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceIpAddress(
        hSystem: acSystem,
        index: usize,
        pIpAddress: *mut u32,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceIpAddressStr(acSystem hSystem, size_t index, char* pIpAddressStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIpAddressStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - IP address as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceIpAddressStr </B> gets the IP address of a device on the\n network, returning it as a string."]
    pub fn acSystemGetDeviceIpAddressStr(
        hSystem: acSystem,
        index: usize,
        pIpAddressStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSubnetMask(acSystem hSystem, size_t index, uint32_t* pSubnetMask)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSubnetMask\n  - Type: uint32_t*\n  - [Out] parameter\n  - Subnet mask as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceSubnetMask </B> gets the subnet mask of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceSubnetMask(
        hSystem: acSystem,
        index: usize,
        pSubnetMask: *mut u32,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceSubnetMaskStr(acSystem hSystem, size_t index, char* pSubnetMaskStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pSubnetMaskStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Subnet mask as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceSubnetMaskStr </B> gets the subnet mask of a device on\n the network, returning it as a string."]
    pub fn acSystemGetDeviceSubnetMaskStr(
        hSystem: acSystem,
        index: usize,
        pSubnetMaskStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceDefaultGateway(acSystem hSystem, size_t index, uint32_t* pDefaultGateway)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pDefaultGateway\n  - Type: uint32_t*\n  - [Out] parameter\n  - Default gateway as an integer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemGetDeviceDefaultGateway(
        hSystem: acSystem,
        index: usize,
        pDefaultGateway: *mut u32,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceDefaultGatewayStr(acSystem hSystem, size_t index, char* pDefaultGatewayStr, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pDefaultGatewayStr\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Default gateway as a dot-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemGetDeviceDefaultGatewayStr(
        hSystem: acSystem,
        index: usize,
        pDefaultGatewayStr: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceMacAddress(acSystem hSystem, size_t index, uint64_t* pMacAddress)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - MAC address as an integer\n\n @param pMacAddress\n  - Type: uint64_t*\n  - [Out] parameter\n  - MAC address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceMacAddress </B> gets the MAC address of a device on the\n network, returning it as its raw integer value."]
    pub fn acSystemGetDeviceMacAddress(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut u64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceMacAddressStr(acSystem hSystem, size_t index, char* pMacAddress, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pMacAddress\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - MAC address as a colon-separated string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceMacAddressStr </B> gets the MAC address of a device on\n the network, returning it as a string."]
    pub fn acSystemGetDeviceMacAddressStr(
        hSystem: acSystem,
        index: usize,
        pMacAddress: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemForceIpAddress(acSystem hSystem, uint64_t macAddress, uint64_t ipAddress, uint64_t subnetMask, uint64_t defaultGateway)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param macAddress\n  - Type: uint64_t\n  - [In] parameter\n  - MAC address\n\n @param ipAddress\n  - Type: uint64_t\n  - [In] parameter\n  - Ip address\n\n @param subnetMask\n  - Type: uint64_t\n  - [In] parameter\n  - subnetMask address\n\n @param defaultGateway\n  - Type: uint64_t\n  - [In] parameter\n  - defaultGateway address\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemForceIpAddress </B> force sets the IP address of a device on the\n network"]
    pub fn acSystemForceIpAddress(
        hSystem: acSystem,
        macAddress: u64,
        ipAddress: u64,
        subnetMask: u64,
        defaultGateway: u64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetDeviceUserDefinedName(acSystem hSystem, size_t index, char* pUserDefinedName, size_t* pBufLen)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pUserDefinedName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - User-defined name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemGetDeviceUserDefinedName </B> gets the user-defined name of a\n device. If supported, it is a customizable string with a maximum of 16 bytes\n that can be used to identify a device."]
    pub fn acSystemGetDeviceUserDefinedName(
        hSystem: acSystem,
        index: usize,
        pUserDefinedName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDeviceDHCPConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsDHCPConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsDHCPConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if DHCP enabled on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDeviceDHCPConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsDHCPConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDevicePersistentIpConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsPersistentIpConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsPersistentIpConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if persisitent IP configuration set on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDevicePersistentIpConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsPersistentIpConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    pub fn acSystemGetDeviceVersion(
        hSystem: acSystem,
        index: usize,
        pDeviceVersion: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemIsDeviceLLAConfigurationEnabled(acSystem hSystem, size_t index, bool8_t* pIsLLAIpConfigurationEnabled)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param pIsLLAIpConfigurationEnabled\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if LLA enabled on device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success"]
    pub fn acSystemIsDeviceLLAConfigurationEnabled(
        hSystem: acSystem,
        index: usize,
        pIsLLAIpConfigurationEnabled: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemCreateDevice(acSystem hSystem, size_t index, acDevice* phDevice)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the device\n\n @param phDevice\n  - Type: acDevice*\n  - [Out] parameter\n  - Initialized, ready-to-use device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemCreateDevice </B> creates and initializes a device. It must be\n called after the device list has been updated (acSystemUpdateDevices). The\n device must be destroyed (acSystemDestroyDevice) when no longer needed.\n\n @see\n  - acSystemUpdateDevices\n  - acSystemDestroyDevice"]
    pub fn acSystemCreateDevice(
        hSystem: acSystem,
        index: usize,
        phDevice: *mut acDevice,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDestroyDevice(acSystem hSystem, acDevice hDevice)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - Device to destroy\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDestroyDevice </B> destroys and cleans up the internal memory of a\n device (acDevice). Devices that have been created (acSystemCreateDevice) must\n be destroyed.\n\n @see\n  - acDevice\n  - acSystemCreateDevice"]
    pub fn acSystemDestroyDevice(hSystem: acSystem, hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemGetTLSystemNodeMap(acSystem hSystem, acNodeMap* phNodeMap)\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the system\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> GetTLSystemNodeMap </B> retrieves the GenTL system node map (acNodeMap),\n used to access system related nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acSystemGetTLSystemNodeMap(hSystem: acSystem, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemRegisterDeviceDisconnectCallback(acSystem hSystem, acDevice hDevice, acCallback* phDeviceDisconnectCallback, acDeviceDisconnectCallbackFunction callbackFn);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device object\n\n @param phDeviceDisconnectCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - Handle to registered acCallback\n\n @param callbackFn\n  - Type: acDeviceDisconnectCallbackFunction\n  - [In] parameter\n  - The device disconnect callback function to register\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemRegisterDeviceDisconnectCallback </B> registers a desconnect callback for specified device.\n When this device is disconnected, user-implemented OnDeviceDisconnected() will be called. The\n user-implemented OnDeviceDisconnected() will receive a handle to the device that was disconnected.\n\n @see\n  - acSystemDeregisterDeviceDisconnectCallback\n  - acSystemDeregisterAllDeviceDisconnectCallbacks"]
    pub fn acSystemRegisterDeviceDisconnectCallback(
        hSystem: acSystem,
        hDevice: acDevice,
        phDeviceDisconnectCallback: *mut acCallback,
        callbackFn: acDeviceDisconnectCallbackFunction,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDeregisterDeviceDisconnectCallback(acSystem hSystem, acCallback hDeviceDisconnectCallback);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @param hDeviceDisconnectCallback\n  - Type: acCallback\n  - [In] parameter\n  - Device disconnect callback object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDeregisterDeviceDisconnectCallback </B> unregisters a previously registered\n callback object. Callbacks can be unregistered whether or not the device is currently\n connected. To deregister all callbacks at once use acSystemDeregisterAllDeviceDisconnectCallbacks.\n\n @see\n  - acSystemRegisterDeviceDisconnectCallback\n  - acSystemDeregisterAllDeviceDisconnectCallbacks"]
    pub fn acSystemDeregisterDeviceDisconnectCallback(
        hSystem: acSystem,
        hDeviceDisconnectCallback: acCallback,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSystemDeregisterAllDeviceDisconnectCallbacks(acSystem hSystem);\n\n @param hSystem\n  - Type: acSystem\n  - [In] parameter\n  - The system object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSystemDeregisterAllDeviceDisconnectCallbacks </B> deregisters all previously\n registered disconnect callback objects. Callbacks can be unregistered whether or\n not the device is currently connected. To deregister an individual\n callback see acSystemDeregisterDeviceDisconnectCallback.\n\n @see\n  - acSystemRegisterDeviceDisconnectCallback\n  - acSystemDeregisterDeviceDisconnectCallback"]
    pub fn acSystemDeregisterAllDeviceDisconnectCallbacks(hSystem: acSystem) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStartStream(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStartStream </B> causes the device to begin streaming image/chunk\n data (acBuffer). It must be called before image or chunk data buffers are\n retrieved (acDeviceGetBuffer). The stream must be stopped\n (acDeviceStopStream) when no longer needed.\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer\n  - acDeviceStopStream"]
    pub fn acDeviceStartStream(hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStartStreamNumBuffersAndFlags(acDevice hDevice, size_t numBuffers)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param numBuffers\n  - Type: size_t\n  - [In] parameter\n  - Number of internal buffers to use in the acquisition engine\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStartStreamNumBuffersAndFlags </B> causes the device to begin\n streaming image/chunk data (acBuffer) with given numBuffers and a streaming\n standard. It must be called before image or chunk data buffers are retrieved\n (acDeviceGetBuffer). The stream must be stopped (acDeviceStopStream) when no\n longer needed.\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer\n  - acDeviceStopStream"]
    pub fn acDeviceStartStreamNumBuffersAndFlags(hDevice: acDevice, numBuffers: usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceStopStream(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceStopStream </B> stops the device from streaming image/chunk data\n (acBuffer) and cleans up the stream. The stream must be stopped when\n streaming is no longer needed.\n\n @see\n  - acBuffer"]
    pub fn acDeviceStopStream(hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetBuffer(acDevice hDevice, uint64_t timeout, acBuffer* phBuffer)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for a buffer\n\n @param phBuffer\n  - Type: acBuffer*\n  - [Out] parameter\n  - Next buffer in the output queue\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetBuffer </B> retrieves a buffer (acBuffer) from the device. It\n must be called after the stream has started (acDeviceStartStream) and before\n the stream has stopped (acDeviceStopStream). Retrieved buffers must be\n requeued (acDeviceRequeueBuffer).\n\n @see\n  - acBuffer\n  - acDeviceStartStream\n  - acDeviceStopStream\n  - acDeviceRequeueBuffer"]
    pub fn acDeviceGetBuffer(hDevice: acDevice, timeout: u64, phBuffer: *mut acBuffer) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceRequeueBuffer(acDevice hDevice, acBuffer pBuffer)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param pBuffer\n  - Type: acBuffer\n  - In parameter\n  - Buffer to requeue\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceRequeueBuffer </B> relinquishes control of a buffer (acBuffer)\n back to Arena. It must be called after a buffer has been retrieved\n (acDeviceGetBuffer).\n\n @see\n  - acBuffer\n  - acDeviceGetBuffer"]
    pub fn acDeviceRequeueBuffer(hDevice: acDevice, pBuffer: acBuffer) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceInitializeEvents(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceInitializeEvents </B> causes the underlying events engine to start\n listening for events. It must be called before waiting on events\n (acDeviceWaitOnEvent). The event infrastructure must be turned off\n (acDeviceDeinitializeEvents) when no longer needed.\n\n @see\n  - acDeviceWaitOnEvent\n  - acDeviceDeinitializeEvents"]
    pub fn acDeviceInitializeEvents(hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceDeinitializeEvents(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> DeinitializeEvents </B> stops the underlying events engine from listening\n for messages, shutting it down and cleaning it up. It should be called only\n after the events infrastructure has been initialized\n (acDeviceInitializeEvents) and after all events have been processed\n (acDeviceWaitOnEvent).\n\n @see\n  - acDeviceInitializeEvents\n  - acDeviceWaitOnEvent"]
    pub fn acDeviceDeinitializeEvents(hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceWaitOnEvent(acDevice hDevice, int64_t timeout)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for an event\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> WaitOnEvent </B> waits for an event to occur in order to process its data.\n It must be called after the event infrastructure has been initialized\n (acDeviceInitializeEvents) and before it is deinitialized\n (acDeviceDeinitializeEvents). This will also trigger callbacks registered to\n event nodes.\n\n @see\n  - acDeviceInitializeEvents\n  - acDeviceDeinitializeEvents"]
    pub fn acDeviceWaitOnEvent(hDevice: acDevice, timeout: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceIsConnected(acDevice hDevice, bool8_t* pIsConnected)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param pIsConnected\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the device is connected\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> IsConnected </B> returns true if a device has been opened and\n maintains a valid communication socket. The device is opened when\n acSystemCreateDevice is called. If the connection to the device\n is lost this will return false.\n\n More specifically, for GigE devices, this flag is set to false when\n the Arena is not able to refresh the heartbeat on the device. If an\n operation times out more than 3 times the device will be flagged as\n not connected.\n\n @see\n  - acSystemCreateDevice"]
    pub fn acDeviceIsConnected(hDevice: acDevice, pIsConnected: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - Main node map for the device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetNodeMap </B> retrieves the already initialized main node map\n (acNodeMap), used to access a device's complete feature set of nodes\n (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLDeviceNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLDeviceNodeMap </B> retrieves the already initialized GenTL\n device node map (acNodeMap), used to access a subset of cached device related\n nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLDeviceNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLStreamNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the stream\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLStreamNodeMap </B> retrieves the already initialized GenTL\n stream node map (acNodeMap), used to access stream related nodes (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLStreamNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceGetTLInterfaceNodeMap(acDevice hDevice, acNodeMap* phNodeMap)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phNodeMap\n  - Type: acNodeMap*\n  - [Out] parameter\n  - GenTL node map for the interface\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceGetTLInterfaceNodeMap </B> retrieves the already initialized GenTL\n interface node map (acNodeMap), used to access interface related nodes\n (acNode).\n\n @see\n  - acNodeMap\n  - acNode"]
    pub fn acDeviceGetTLInterfaceNodeMap(hDevice: acDevice, phNodeMap: *mut acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceRegisterImageCallback(acDevice hDevice, acCallback* phCallback, acImageCallbackFunction callbackFn, void* pParam);\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - Handle to registered acCallback\n\n @param callbackFn\n  - Type: acImageCallbackFunction\n  - [In] parameter\n  - The image callback function to register\n\n @param pParam\n  - Type: void*\n  - [In] parameter\n  - Pointer to optional user-specified callback data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceRegisterImageCallback </B> registers the specified image callback\n function for the device. The optional user-specified data will be passed to\n the image callback function.\n\n @see\n  - acDeviceDeregisterImageCallback"]
    pub fn acDeviceRegisterImageCallback(
        hDevice: acDevice,
        phCallback: *mut acCallback,
        callbackFn: acImageCallbackFunction,
        pParam: *mut ::std::os::raw::c_void,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceDeregisterImageCallback(acDevice hDevice, acCallback* phCallback);\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param phCallback\n  - Type: acCallback*\n  - [In] parameter\n  - Handle to registered acCallback\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceDeregisterImageCallback </B> deregisters the specified image\n callback for the device.\n\n @see\n  - acDeviceRegisterImageCallback"]
    pub fn acDeviceDeregisterImageCallback(
        hDevice: acDevice,
        phCallback: *mut acCallback,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceWaitForNextLeader(acDevice hDevice, int64_t timeout)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @param timeout\n  - Type: uint64_t\n  - [In] parameter\n  - Maximum time to wait for next leader\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceWaitForNextLeader </B> will wait until the leader for the next image\n has arrived. It must be called after the stream has started\n (acDeviceStartStream) and before the stream has stopped\n (acDeviceStopStream).\n\n This function can be used to determine when the host has received the\n leader for the next image. Note that if the time that the camera has\n finished the exposure for the next image is desired, it is\n recommended to use the GenICam ExposureEnd Event instead.\n\n @see\n  - acDeviceResetWaitForNextLeader\n  - acDeviceStartStream\n  - acDeviceStopStream"]
    pub fn acDeviceWaitForNextLeader(hDevice: acDevice, timeout: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acDeviceResetWaitForNextLeader(acDevice hDevice)\n\n @param hDevice\n  - Type: acDevice\n  - [In] parameter\n  - A device\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acDeviceResetWaitForNextLeader </B> clears any pending flag for a received leader event.\n\n @see\n  - acDeviceWaitForNextLeader\n  - acDeviceStartStream\n  - acDeviceStopStream"]
    pub fn acDeviceResetWaitForNextLeader(hDevice: acDevice) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetSizeFilled(acBuffer hBuffer, size_t* pSizeFilled)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pSizeFilled\n  - Type: size_t*\n  - [Out] parameter\n  - Size of the payload\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetSizeFilled </B> retrieves the size of the payload data,\n excluding transport layer protocol leaders. The payload data may include image\n data, chunk data, or both."]
    pub fn acBufferGetSizeFilled(hBuffer: acBuffer, pSizeFilled: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetPayloadSize(acBuffer hBuffer, size_t* pPayloadSize)\n\n @return\n  - Type: size_t\n  - Unit: bytes\n  - Size of the intended payload\n\n <B> GetPayloadSize </B> retrieves the intended size of the payload. This is\n similar to the retrieved payload size (acBufferGetSizeFilled), but different\n in that missed data is included.\n\n @warning\n  - Causes undefined behavior if buffer\n\n @see\n  - acBufferGetSizeFilled"]
    pub fn acBufferGetPayloadSize(hBuffer: acBuffer, pPayloadSize: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetSizeOfBuffer(acBuffer hBuffer, size_t* pSizeOfBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pSizeOfBuffer\n  - Type: size_t*\n  - [Out] parameter\n  - Size of the buffer\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetSizeOfBuffer </B> retrieves the size of a buffer."]
    pub fn acBufferGetSizeOfBuffer(hBuffer: acBuffer, pSizeOfBuffer: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetFrameId(acBuffer hBuffer, uint64_t* pFrameId)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pFrameId\n  - Type: uint64_t*\n  - [Out] parameter\n  - Frame ID\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetFrameId </B> gets the frame ID, a sequential identifier for\n buffers."]
    pub fn acBufferGetFrameId(hBuffer: acBuffer, pFrameId: *mut u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferGetPayloadType(acBuffer hBuffer, AC_PAYLOAD_TYPE* pPayloadType)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pPayloadType\n  - Type: AC_PAYLOAD_TYPE*\n  - [Out] parameter\n  - Type of payload data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferGetPayloadType </B> returns a buffer's payload type\n (AC_PAYLOAD_TYPE), as defined by the GigE Vision specification."]
    pub fn acBufferGetPayloadType(
        hBuffer: acBuffer,
        pPayloadType: *mut AC_PAYLOAD_TYPE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferHasChunkData(acBuffer hBuffer, bool8_t* pHasChunkData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pHasChunkData\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload has chunk data\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferHasChunkData </B> returns whether or not a buffer's payload that\n may be interpreted as chunk data."]
    pub fn acBufferHasChunkData(hBuffer: acBuffer, pHasChunkData: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferHasImageData(acBuffer hBuffer, bool8_t* pHasImageData)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pHasImageData\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload has image data\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferHasChunkData </B> returns whether or not a buffer's payload that\n may be interpreted as chunk data."]
    pub fn acBufferHasImageData(hBuffer: acBuffer, pHasImageData: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferIsIncomplete(acBuffer hBuffer, bool8_t* pIsIncomplete)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pIsIncomplete\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the data is incomplete\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferIsIncomplete </B> returns whether or not the payload is complete."]
    pub fn acBufferIsIncomplete(hBuffer: acBuffer, pIsIncomplete: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferDataLargerThanBuffer(acBuffer hBuffer, bool8_t* pDataLargerThanBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pDataLargerThanBuffer\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the payload is larger than the buffer\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferDataLargerThanBuffer </B> returns whether or not a buffer's\n payload data is larger than the buffer."]
    pub fn acBufferDataLargerThanBuffer(
        hBuffer: acBuffer,
        pDataLargerThanBuffer: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBufferVerifyCRC(acBuffer hBuffer, bool8_t* pVerifyCRC)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A buffer\n\n @param pVerifyCRC\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the calculated CRC value equals the one sent from the device\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBufferVerifyCRC </B> calculates the CRC of a buffer's data and verifies\n it against the CRC value sent from the device via chunk data. This helps\n verify that no data has been changed or missed during a transmission. This\n function calls a global helper function to calculate the CRC\n (acCalculateCRC32).\n\n @see\n  - acCalculateCRC"]
    pub fn acBufferVerifyCRC(hBuffer: acBuffer, pVerifyCRC: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetWidth(acBuffer hBuffer, size_t* pWidth)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pWidth\n  - Type: size_t*\n  - [Out] parameter\n  - Width of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetWidth </B> gets the width of the image in pixels. Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetWidth(hBuffer: acBuffer, pWidth: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetHeight(acBuffer hBuffer, size_t* pHeight)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pHeight\n  - Type: size_t*\n  - [Out] parameter\n  - Height of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetHeight </B> gets the height of the image. Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetHeight(hBuffer: acBuffer, pHeight: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetOffsetX(acBuffer hBuffer, size_t* pOffsetX)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pOffsetX\n  - Type: size_t*\n  - [Out] parameter\n  - Offset X of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetOffsetX </B> gets the offset of the image along the X-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetOffsetX(hBuffer: acBuffer, pOffsetX: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetOffsetY(acBuffer hBuffer, size_t* pOffsetY)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pOffsetY\n  - Type: size_t*\n  - [Out] parameter\n  - Offset Y of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetOffsetY </B> gets the offset of the image along the Y-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetOffsetY(hBuffer: acBuffer, pOffsetY: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPaddingX(acBuffer hBuffer, size_t* pPaddingX)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pPaddingX\n  - Type: size_t*\n  - [Out] parameter\n  - Padding X of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPaddingX </B> gets the padding of the image along the X-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetPaddingX(hBuffer: acBuffer, pPaddingX: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPaddingY(acBuffer hBuffer, size_t* pPaddingY)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pPaddingY\n  - Type: size_t*\n  - [Out] parameter\n  - Padding Y of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPaddingY </B> gets the padding of the image along the Y-axis.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetPaddingY(hBuffer: acBuffer, pPaddingY: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPixelFormat(acBuffer hBuffer, uint64_t* pPixelFormat)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pPixelFormat\n  - Type: uint64_t*\n  - [Out] parameter\n  - Pixel format of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPixelFormat </B> gets the pixel format (PfncFormat) of the\n image, as defined by the PFNC (Pixel Format Naming Convention). Images are\n self-describing, so the device does not need to be queried to get this\n information."]
    pub fn acImageGetPixelFormat(hBuffer: acBuffer, pPixelFormat: *mut u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetBitsPerPixel(acBuffer hBuffer, size_t* pBitsPerPixel)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pBitsPerPixel\n  - Type: size_t*\n  - [Out] parameter\n  - Bits per pixel of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetBitsPerPixel </B> gets the number of bits per pixel of the image\n from the integer value of the pixel format (PfncFormat). Internally, a public\n helper funciton is called (acGetBitsPerPixel).\n\n @see\n  - acGetBitsPerPixel"]
    pub fn acImageGetBitsPerPixel(hBuffer: acBuffer, pBitsPerPixel: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetPixelEndianness(acBuffer hBuffer, AC_PIXEL_ENDIANNESS* pPixelEndianness)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pPixelEndianness\n  - Type: AC_PIXEL_ENDIANNESS*\n  - [Out] parameter\n  - Endianness of the pixels of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetPixelEndianness </B> gets the pixel endianness\n (AC_PIXEL_ENDIANNESS) of the image. Images are self-describing, so the\n device does not need to be queried to get this information."]
    pub fn acImageGetPixelEndianness(
        hBuffer: acBuffer,
        pPixelEndianness: *mut AC_PIXEL_ENDIANNESS,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetTimestamp(acBuffer hBuffer, uint64_t* pTimestamp)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pTimestamp\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetTimestamp </B> gets the timestamp of the image in nanoseconds.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetTimestamp(hBuffer: acBuffer, pTimestamp: *mut u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetTimestampNs(acBuffer hBuffer, uint64_t* pTimestampNs)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param pTimestampNs\n  - Type: uint64_t*\n  - Unit: nanoseconds\n  - [Out] parameter\n  - Timestamp of the image in nanoseconds\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetTimestampNs </B> gets the timestamp of the image in nanoseconds.\n Images are self-describing, so the device does not need to be queried to get\n this information."]
    pub fn acImageGetTimestampNs(hBuffer: acBuffer, pTimestampNs: *mut u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageGetData(acBuffer hBuffer, uint8_t** ppData)\n\n @param hBuffer\n  - Type: acBuffer\n  - In parameter\n  - An image\n\n @param ppData\n  - Type: uint8_t**\n  - [Out] parameter\n  - Point to the payload data\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageGetData </B> returns a pointer to the beginning of the image's\n payload data. The payload may include chunk data."]
    pub fn acImageGetData(hBuffer: acBuffer, ppData: *mut *mut u8) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acChunkDataGetChunk(acBuffer hBuffer, const char* pName, acNode* phChunk)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A chunk data\n\n @param pName\n  - Type: const char*\n  - [In] parameter\n  - Name of the chunk\n  - Prefixed with 'Chunk'\n\n @param phChunk\n  - Type: acNode*\n  - [Out] parameter\n  - Requested node\n  - Null on failure\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acChunkDataGetChunk </B> gets a specified chunk, which can be used to\n retrieve the chunk value and related information available in its node type\n (maximum, minimum, node display name, etc)."]
    pub fn acChunkDataGetChunk(
        hBuffer: acBuffer,
        pName: *const ::std::os::raw::c_char,
        phChunk: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acChunkDataGetChunkAndAccessMode(acBuffer hBuffer, const char* pName, acNode* phChunkNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - A chunk data\n\n @param pName\n  - Type: const char*\n  - [In] parameter\n  - Name of the chunk\n  - Prefixed with 'Chunk'\n\n @param phChunkNode\n  - Type: acNode*\n  - [Out] parameter\n  - Requested node\n  - Null on failure\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Access mode of the requested node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acChunkDataGetChunkAndAccessMode </B> gets a specified chunk and its\n access mode, returning it as a node in order to preserve metadata related to\n the chunk."]
    pub fn acChunkDataGetChunkAndAccessMode(
        hBuffer: acBuffer,
        pName: *const ::std::os::raw::c_char,
        phChunkNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryCreate(uint8_t* pData, size_t dataSize, size_t width, size_t height, uint64_t pixelFormat, acBuffer* phDst)\n\n FactoryCreate(uint8_t pData, size_t dataSize, size_t width, size_t height,\n uint64_t pixelFormat, acBuffer* phDst)\n\n @param pData\n  - Type: uint8_t*\n  - [Out] parameter\n  - Pointer to the beginning of the payload data\n\n @param dataSize\n  - Type: size_t\n  - [In] parameter\n  - Size of the data\n\n @param width\n  - Type: size_t\n  - [In] parameter\n  - Width of the image to create\n\n @param height\n  - Type: size_t\n  - [In] parameter\n  - Height of the image to create\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format of the image to create\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Image created from the parameters\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryCreate </B> creates an image (acBuffer) from a minimal set\n of parameters. Images created with the image factory must be destroyed\n (acImageFactoryDestroy) when no longer needed.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryCreate(
        pData: *mut u8,
        dataSize: usize,
        width: usize,
        height: usize,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryCopy(acBuffer hSrc, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to copy\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Deep copy of the image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryCopy </B> creates a deep copy of an image (acBuffer) from\n another image. Images created with the image factory must be destroyed\n (acImageFactoryDestroy) when no longer needed.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryCopy(hSrc: acBuffer, phDst: *mut acBuffer) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryConvert(acBuffer hSrc, uint64_t pixelFormat, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to convert\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to convert to\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Convert image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryConvert </B> converts an image (acBuffer) to a select pixel\n format. In doing so, it creates a completely new image, similar to a deep copy\n but with a different pixel format. Images created with the image factory must\n be destroyed (acImageFactoryDestroy) when no longer needed; otherwise, memory\n will leak.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryConvert(
        hSrc: acBuffer,
        pixelFormat: u64,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryConvertBayerAlgorithm(acBuffer hSrc, uint64_t pixelFormat, AC_BAYER_ALGORITHM bayerAlgo, acBuffer* phDst)\n\n @param hSrc\n  - Type: acBuffer\n  - [In] parameter\n  - Image to convert\n\n @param pixelFormat\n  - Type: uint64_t\n  - [In] parameter\n  - Pixel format to convert to\n\n @param bayerAlgo\n  - Type: AC_BAYER_ALGORITHM\n  - [In] parameter\n  - Bayer conversion algorithm to use\n  - Only applicable when converting from bayer\n\n @param phDst\n  - Type: acBuffer*\n  - [Out] parameter\n  - Converted image\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryConvert </B> converts an image (acBuffer) to a select pixel\n format. In doing so, it creates a completely new image, similar to a deep copy\n but with a different pixel format. Images created with the image factory must\n be destroyed (acImageFactoryDestroy) when no longer needed; otherwise, memory\n will leak.\n\n @see\n  - acBuffer\n  - acImageFactoryDestroy"]
    pub fn acImageFactoryConvertBayerAlgorithm(
        hSrc: acBuffer,
        pixelFormat: u64,
        bayerAlgo: AC_BAYER_ALGORITHM,
        phDst: *mut acBuffer,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acImageFactoryDestroy(acBuffer hBuffer)\n\n @param hBuffer\n  - Type: acBuffer\n  - [In] parameter\n  - Image to destroy\n  - Image must be from image factory\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acImageFactoryDestroy </B> cleans up an image (acBuffer) and deallocates\n its memory. It must be called on any image created by the image factory\n (acImageFactoryCreate, acImageFactoryCopy, acImageFactoryConvert).\n\n @see\n  - acBuffer\n  - acImageFactoryCreate"]
    pub fn acImageFactoryDestroy(hBuffer: acBuffer) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamCreate(acNodeMap hNodeMap, acFeatureStream* phFeatureStream)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - Node map to stream\n\n @param phFeatureStream\n  - Type: acFeatureStream*\n  - [Out] parameter\n  - Feature stream object to create\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStream </B> builds a feature stream from a device's node map\n (acNodeMap). This node map cannot be changed later; another feature stream\n must be created to stream another node map.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamCreate(
        hNodeMap: acNodeMap,
        phFeatureStream: *mut acFeatureStream,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamDestroy(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - Feature stream object to destroy\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamDestroy </B> destroys a feature stream object, cleaning up\n allocated memory."]
    pub fn acFeatureStreamDestroy(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamWrite(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamWrite </B> streams all selected features from the node map\n (acNodeMap) to a file.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamWrite(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamWriteFileName(acFeatureStream hFeatureStream, const char* pFileName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - Name of the file to stream to\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamWriteFileName </B> streams all selected features from the\n node map (acNodeMap) to a file.\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamWriteFileName(
        hFeatureStream: acFeatureStream,
        pFileName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamRead(acFeatureStream hFeatureStream)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamRead </B> streams all selected features from a file to the\n node map (acNodeMap).\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamRead(hFeatureStream: acFeatureStream) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamReadFileName(acFeatureStream hFeatureStream, const char* pFileName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFileName\n  - Type: const char*\n  - [In] parameter\n  - Name of the file to stream from\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamReadFileName </B> streams all selected features from a file\n to the node map (acNodeMap).\n\n @see\n  - acNodeMap"]
    pub fn acFeatureStreamReadFileName(
        hFeatureStream: acFeatureStream,
        pFileName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFeatureStreamSelect(acFeatureStream hFeatureStream, const char* pFeatureName)\n\n @param hFeatureStream\n  - Type: acFeatureStream\n  - [In] parameter\n  - The feature stream object\n\n @param pFeatureName\n  - Type: const char*\n  - [In] parameter\n  - Name of the feature to select\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFeatureStreamSelect </B> adds a single streamable feature to the list of\n selected features to stream. If called for the first time, <B>\n acFeatureStreamSelect </B> also sets an internal 'select-all' flag to false."]
    pub fn acFeatureStreamSelect(
        hFeatureStream: acFeatureStream,
        pFeatureName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNode(acNodeMap hNodeMap, const char* pNodeName, acNode* phNode)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node to retrieve\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node."]
    pub fn acNodeMapGetNode(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        phNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeAndAccessMode(acNodeMap hNodeMap, const char* pNodeName, acNode* phNode, AC_ACCESS_MODE* pNodeAccess)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node to retrieve\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @param pNodeAccess\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - The node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNodeAndAccessMode </B> retrieves a node with its access mode."]
    pub fn acNodeMapGetNodeAndAccessMode(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        phNode: *mut acNode,
        pNodeAccess: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapInvalidateNodes(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapInvalidateNodes </B> invalidates all of its nodes."]
    pub fn acNodeMapInvalidateNodes(hNodeMap: acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetDeviceName(acNodeMap hNodeMap, char* pDeviceNameBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pDeviceNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Name of the device\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetDeviceName </B> retrieves the node map's device name."]
    pub fn acNodeMapGetDeviceName(
        hNodeMap: acNodeMap,
        pDeviceNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapPoll(acNodeMap hNodeMap, int64_t elapsedTime)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param elapsedTime\n  - Type: int64_t\n  - Unit: milliseconds\n  - [In] parameter\n  - Time since the last poll\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapPoll </B> polls the node map."]
    pub fn acNodeMapPoll(hNodeMap: acNodeMap, elapsedTime: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapLock(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> locks the node map."]
    pub fn acNodeMapLock(hNodeMap: acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapUnlock(acNodeMap hNodeMap)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> unlocks the node map."]
    pub fn acNodeMapUnlock(hNodeMap: acNodeMap) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapTryLock(acNodeMap hNodeMap, bool8_t* pLocked)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pLocked\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the lock succeeded\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> tries to lock the node map, returning whether or not\n the call succeeded."]
    pub fn acNodeMapTryLock(hNodeMap: acNodeMap, pLocked: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNumNodes(acNodeMap hNodeMap, uint64_t* pNumNodes)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNumNodes\n  - Type: uint64_t*\n  - [Out] parameter\n  - Total number of nodes in the node map\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves the number of nodes in the node map."]
    pub fn acNodeMapGetNumNodes(hNodeMap: acNodeMap, pNumNodes: *mut u64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeByIndex(acNodeMap hNodeMap, size_t index, acNode* phNode)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the node\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node by its index."]
    pub fn acNodeMapGetNodeByIndex(
        hNodeMap: acNodeMap,
        index: usize,
        phNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetNodeByIndexAndAccessMode(acNodeMap hNodeMap, size_t index, acNode* phNode, AC_ACCESS_MODE* pNodeAccess)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the node\n\n @param phNode\n  - Type: acNode*\n  - [Out] parameter\n  - The node\n\n @param pNodeAccess\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - The node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetNode </B> retrieves a node by its index along with its access\n mode."]
    pub fn acNodeMapGetNodeByIndexAndAccessMode(
        hNodeMap: acNodeMap,
        index: usize,
        phNode: *mut acNode,
        pNodeAccess: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetStringValue(acNodeMap hNodeMap, const char* pNodeName, char* pValueBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValueBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Value of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetStringValue </B> acts as a shortcut for retrieving the value\n of a string node."]
    pub fn acNodeMapGetStringValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValueBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetIntegerValue(acNodeMap hNodeMap, const char* pNodeName, int64_t* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetIntegerValue </B> acts as a shortcut for retrieving the value\n of an integer node."]
    pub fn acNodeMapGetIntegerValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut i64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetFloatValue(acNodeMap hNodeMap, const char* pNodeName, double* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetFloatValue </B> acts as a shortcut for retrieving the value of\n a float node."]
    pub fn acNodeMapGetFloatValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut f64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetBooleanValue(acNodeMap hNodeMap, const char* pNodeName, bool8_t* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: bool8_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetBooleanValue </B> acts as a shortcut for retrieving the value\n of a boolean node."]
    pub fn acNodeMapGetBooleanValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *mut bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapGetEnumerationValue(acNodeMap hNodeMap, const char* pNodeName, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the current entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapGetEnumerationValue </B> acts as a shortcut for retrieving the\n entry of an enumeration node."]
    pub fn acNodeMapGetEnumerationValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetStringValue(acNodeMap hNodeMap, const char* pNodeName, const char* pValue)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - String value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetStringValue </B> acts as a shortcut for setting the value of a\n string node."]
    pub fn acNodeMapSetStringValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pValue: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetIntegerValue(acNodeMap hNodeMap, const char* pNodeName, int64_t value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Integer value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetIntegerValue </B> acts as a shortcut for setting the value of\n an integer node."]
    pub fn acNodeMapSetIntegerValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: i64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetFloatValue(acNodeMap hNodeMap, const char* pNodeName, double value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: double\n  - [In] parameter\n  - Float value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetFloatValue </B> acts as a shortcut for setting the value of a\n float node."]
    pub fn acNodeMapSetFloatValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: f64,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetBooleanValue(acNodeMap hNodeMap, const char* pNodeName, bool8_t value)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param value\n  - Type: bool8_t\n  - [In] parameter\n  - Boolean value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetBooleanValue </B> acts as a shortcut for setting the value of\n a boolean node."]
    pub fn acNodeMapSetBooleanValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        value: bool8_t,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapSetEnumerationValue(acNodeMap hNodeMap, const char* pNodeName, const char* pSymbolic)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @param pSymbolic\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry node to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapSetEnumerationValue </B> acts as a shortcut for setting the value\n of an enumeration node."]
    pub fn acNodeMapSetEnumerationValue(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
        pSymbolic: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeMapExecute(acNodeMap hNodeMap, const char* pNodeName)\n\n @param hNodeMap\n  - Type: acNodeMap\n  - [In] parameter\n  - A node map\n\n @param pNodeName\n  - Type: const char*\n  - [In] parameter\n  - Name of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns SC_ERR_SUCCESS (0) on success\n\n <B> acNodeMapExecute </B> acts as a shortcut for executing a command node."]
    pub fn acNodeMapExecute(
        hNodeMap: acNodeMap,
        pNodeName: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCallbackRegister(acCallback* phCallback, acNode hNode, acCallbackFunction callbackFunction, void* pUserData)\n\n @param phCallback\n  - Type: acCallback*\n  - [Out] parameter\n  - The callback handle\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node to set the callback on\n\n @param callbackFunction\n  - Type: acCallbackFunction\n  - [In] parameter\n  - The function to call\n\n @param pUserData\n  - Type: void*\n  - [Out] parameter\n  - Accepts null\n  - User data available within the callback function\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCallbackRegister </B> registers a callback on a node. The callback\n handle (acCallback) should be stored in order to deregister the callback\n later.\n\n @see\n  - acCallback"]
    pub fn acCallbackRegister(
        phCallback: *mut acCallback,
        hNode: acNode,
        callbackFunction: acCallbackFunction,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCallbackDeregister(acCallback hCallback)\n\n @param hCallback\n  - Type: acCallback\n  - [In] parameter\n  - The callback handle\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCallbackDeregister </B> deregisters the callback."]
    pub fn acCallbackDeregister(hCallback: acCallback) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetAccessMode(acNode hNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetAccessMode </B> retrieves a node's access mode."]
    pub fn acNodeGetAccessMode(hNode: acNode, pAccessMode: *mut AC_ACCESS_MODE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetAlias(acNode hNode, acNode* phAliasNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param phAliasNode\n  - Type: acNode*\n  - [Out] parameter\n  - Alias node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetAlias </B> retrieves a node's alias node."]
    pub fn acNodeGetAlias(hNode: acNode, phAliasNode: *mut acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetCachingMode(acNode hNode, AC_CACHING_MODE* pCachingMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pCachingMode\n  - Type: AC_CACHING_MODE*\n  - [Out] parameter\n  - Caching mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetCachingMode </B> retrieves a node's caching mode."]
    pub fn acNodeGetCachingMode(hNode: acNode, pCachingMode: *mut AC_CACHING_MODE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetCastAlias(acNode hNode, acNode* phAliasNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param phAliasNode\n  - Type: acNode*\n  - [Out] parameter\n  - Cast alias\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetCastAlias </B> retrieves a node's cast alias."]
    pub fn acNodeGetCastAlias(hNode: acNode, phAliasNode: *mut acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumChildren(acNode hNode, size_t* pNumChildren)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumChildren\n  - Type: size_t*\n  - [Out] parameter\n  - Number of child nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumChildren </B> retrieves the number of a node's children."]
    pub fn acNodeGetNumChildren(hNode: acNode, pNumChildren: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetChild(acNode hNode, size_t index, acNode* phChildNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the child\n\n @param phChildNode\n  - Type: acNode*\n  - [Out] parameter\n  - Child node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetChild </B> retrieves a node's child node."]
    pub fn acNodeGetChild(hNode: acNode, index: usize, phChildNode: *mut acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetChildAndAccessMode(acNode hNode, size_t index, acNode* phChildNode, AC_ACCESS_MODE* accessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the child\n\n @param phChildNode\n  - Type: acNode*\n  - [Out] parameter\n  - Child node\n\n @param accessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Child node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetChildAndAccessMode </B> retrieves a node's child node and the\n child's access mode."]
    pub fn acNodeGetChildAndAccessMode(
        hNode: acNode,
        index: usize,
        phChildNode: *mut acNode,
        accessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDescription(acNode hNode, char* pDescription, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDescription\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Description of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDescription </B> retrieves a node's longer description."]
    pub fn acNodeGetDescription(
        hNode: acNode,
        pDescription: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDeviceName(acNode hNode, char* pDeviceName, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDeviceName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Device name of the node\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDeviceName </B> retrieves a node's device name."]
    pub fn acNodeGetDeviceName(
        hNode: acNode,
        pDeviceName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDisplayName(acNode hNode, char* pDisplayName, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDisplayName\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Display name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDisplayName </B> retrieves a node's display name."]
    pub fn acNodeGetDisplayName(
        hNode: acNode,
        pDisplayName: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetDocuURL(acNode hNode, char* pDocuURL, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pDocuURL\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Document URL\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetDocuURL </B> retrieves a node's document URL."]
    pub fn acNodeGetDocuURL(
        hNode: acNode,
        pDocuURL: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetEventID(acNode hNode, char* pEventIDBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pEventIDBuf\n  - Type: char*\n  - [Out] parameter\n  - Event ID\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetEventID </B> retrieves a node's event ID."]
    pub fn acNodeGetEventID(
        hNode: acNode,
        pEventIDBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetName(acNode hNode, char* pNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetName </B> retrieves a node's name."]
    pub fn acNodeGetName(
        hNode: acNode,
        pNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetFullyQualifiedName(acNode hNode, char* pNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - In parameter\n  - The node\n  - Accepts any node type\n\n @param pNameBuf\n  - Type: char*\n  - Out parameter\n  - Accepts null\n  - Name\n\n @param pBufLen\n  - Type: size_t*\n  - In/out parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetFullyQualifiedName </B> retrieves a node's fully qualified name."]
    pub fn acNodeGetFullyQualifiedName(
        hNode: acNode,
        pNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNamespace(acNode hNode, AC_NAMESPACE* pNameSpace)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNameSpace\n  - Type: AC_NAMESPACE*\n  - [Out] parameter\n  - Namespace\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNamespace </B> retrieves a node's namespace."]
    pub fn acNodeGetNamespace(hNode: acNode, pNameSpace: *mut AC_NAMESPACE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumParents(acNode hNode, size_t* pNumParents)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumParents\n  - Type: size_t*\n  - [Out] parameter\n  - Number of parent nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumParents </B> retrieves the number of a node's parents."]
    pub fn acNodeGetNumParents(hNode: acNode, pNumParents: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetParent(acNode hNode, size_t index, acNode* phParentNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the parent\n\n @param phParentNode\n  - Type: acNode*\n  - [Out] parameter\n  - The parent node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetParent </B> retrieves a node's parent node."]
    pub fn acNodeGetParent(hNode: acNode, index: usize, phParentNode: *mut acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetParentAndAccessMode(acNode hNode, size_t index, acNode* phParentNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the parent node\n\n @param phParentNode\n  - Type: acNode*\n  - [Out] parameter\n  - The parent node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Parent node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetParentAndAccessMode </B> retrieves a node's parent node and the\n parent's access mode."]
    pub fn acNodeGetParentAndAccessMode(
        hNode: acNode,
        index: usize,
        phParentNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPollingTime(acNode hNode, int64_t* pPollingTime)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pPollingTime\n  - Type: int64_t*\n  - [Out] parameter\n  - Polling time\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPollingTime </B> retrieves a node's polling time in milliseconds."]
    pub fn acNodeGetPollingTime(hNode: acNode, pPollingTime: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPrincipalInterfaceType(acNode hNode, AC_INTERFACE_TYPE* pInterfaceType)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pInterfaceType\n  - Type: AC_INTERFACE_TYPE*\n  - [Out] parameter\n  - Node type\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPrincipalInterfaceType </B> retrieves a node's type."]
    pub fn acNodeGetPrincipalInterfaceType(
        hNode: acNode,
        pInterfaceType: *mut AC_INTERFACE_TYPE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetProperty(acNode hNode, const char* pPropertyName, char* pPropertyValueBuf, size_t* pPropertyValueBufLen, char* pPropertyAttributeBuf, size_t* pPropertyAttributeBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pPropertyName\n  - Type: const char*\n  - [In] parameter\n  - Accepts null\n  - List of property names\n\n @param pPropertyValueBuf\n  - Type: char*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @param pPropertyValueBufLen\n  - Type: size_t*\n  - [Out] parameter\n  - Accepts null\n  - List of property values\n\n @param pPropertyAttributeBuf\n  - Type: char*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @param pPropertyAttributeBufLen\n  - Type: size_t*\n  - [Out] parameter\n  - The node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetProperty </B> retrieves a node's properties and their values."]
    pub fn acNodeGetProperty(
        hNode: acNode,
        pPropertyName: *const ::std::os::raw::c_char,
        pPropertyValueBuf: *mut ::std::os::raw::c_char,
        pPropertyValueBufLen: *mut usize,
        pPropertyAttributeBuf: *mut ::std::os::raw::c_char,
        pPropertyAttributeBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetNumPropertyNames(acNode hNode, size_t* pNumPropertyNames)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pNumPropertyNames\n  - Type: size_t*\n  - [Out] parameter\n  - Number of node properties\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetNumPropertyNames </B> retrieves the number of a node's property\n names."]
    pub fn acNodeGetNumPropertyNames(hNode: acNode, pNumPropertyNames: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetPropertyName(acNode hNode, size_t index, char* pPropertyNameBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the property\n\n @param pPropertyNameBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Property name\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetPropertyName </B> retrieves a node's property name."]
    pub fn acNodeGetPropertyName(
        hNode: acNode,
        index: usize,
        pPropertyNameBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetToolTip(acNode hNode, char* pToolTipBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pToolTipBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Tool tip\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetToolTip </B> retrieves a node's shorter description."]
    pub fn acNodeGetToolTip(
        hNode: acNode,
        pToolTipBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeInvalidateNode(acNode hNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeInvalidateNode </B> invalidates a node."]
    pub fn acNodeInvalidateNode(hNode: acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeGetVisibility(acNode hNode, AC_VISIBILITY* pVisibility)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pVisibility\n  - Type: AC_VISIBILITY*\n  - [Out] parameter\n  - Visibility\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeGetVisibility </B> retrieves a node's suggested visibility."]
    pub fn acNodeGetVisibility(hNode: acNode, pVisibility: *mut AC_VISIBILITY) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeImposeAccessMode(acNode hNode, AC_ACCESS_MODE imposedAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param imposedAccessMode\n  - Type: AC_ACCESS_MODE\n  - [In] parameter\n  - Imposed access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeImposeAccessMode </B> imposes an access mode on a node."]
    pub fn acNodeImposeAccessMode(hNode: acNode, imposedAccessMode: AC_ACCESS_MODE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeImposeVisibility(acNode hNode, AC_VISIBILITY imposedVisibility)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param imposedVisibility\n  - Type: AC_VISIBILITY\n  - [In] parameter\n  - Imposed visibility\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeImposeVisibility </B> imposes a visibility setting on a node."]
    pub fn acNodeImposeVisibility(hNode: acNode, imposedVisibility: AC_VISIBILITY) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsCachable(acNode hNode, bool8_t* pIsCachable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsCachable\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node value is cachable\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsCachable </B> retrieves whether or not a node is cachable."]
    pub fn acNodeIsCachable(hNode: acNode, pIsCachable: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsDeprecated(acNode hNode, bool8_t* pIsDeprecated)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsDeprecated\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is deprecated\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsDeprecated </B> retrieves whether or not a node is deprecated."]
    pub fn acNodeIsDeprecated(hNode: acNode, pIsDeprecated: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsFeature(acNode hNode, bool8_t* pIsFeature)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsFeature\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is a feature\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsFeature </B> retrieves whether or not a node is a feature."]
    pub fn acNodeIsFeature(hNode: acNode, pIsFeature: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acNodeIsStreamable(acNode hNode, bool8_t* pIsStreamable)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - The node\n  - Accepts any node type\n\n @param pIsStreamable\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is streamable\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acNodeIsStreamable </B> retrieves whether or not a node is streamable."]
    pub fn acNodeIsStreamable(hNode: acNode, pIsStreamable: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueToString(acNode hNode, char* pValueBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pValueBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Value as a string\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueToString </B> gets a node's value as a string."]
    pub fn acValueToString(
        hNode: acNode,
        pValueBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueFromString(acNode hNode, const char* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - Value as a string\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueFromString </B> sets a node's value from a string."]
    pub fn acValueFromString(hNode: acNode, pValue: *const ::std::os::raw::c_char) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acValueIsValueCacheValid(acNode hNode, bool8_t* pIsValid)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts any node type\n\n @param pIsValid\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if cache value is valid\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acValueIsValueCacheValid </B> retrieves whether or not a node's value\n cache is valid."]
    pub fn acValueIsValueCacheValid(hNode: acNode, pIsValid: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetInc(acNode hNode, int64_t* pIncrement)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pIncrement\n  - Type: int64_t*\n  - [Out] parameter\n  - Value increment\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetInc </B> retrieves the increment between valid values."]
    pub fn acIntegerGetInc(hNode: acNode, pIncrement: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetIncMode(acNode hNode, AC_INC_MODE* pIncrementMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pIncrementMode\n  - Type: AC_INC_MODE*\n  - [Out] parameter\n  - Increment mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetIncMode </B> retrieves the increment mode."]
    pub fn acIntegerGetIncMode(hNode: acNode, pIncrementMode: *mut AC_INC_MODE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetMax(acNode hNode, int64_t* pMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pMaximum\n  - Type: int64_t*\n  - [Out] parameter\n  - Maximum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetMax </B> retrieves the maximum value."]
    pub fn acIntegerGetMax(hNode: acNode, pMaximum: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetMin(acNode hNode, int64_t* pMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pMinimum\n  - Type: int64_t*\n  - [Out] parameter\n  - Minimum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetMin </B> retrieves the minimum value."]
    pub fn acIntegerGetMin(hNode: acNode, pMinimum: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetRepresentation(acNode hNode, AC_REPRESENTATION* pRepresentation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pRepresentation\n  - Type: AC_REPRESENTATION*\n  - [Out] parameter\n  - Numeric representation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetRepresentation </B> retrieves the value representation."]
    pub fn acIntegerGetRepresentation(
        hNode: acNode,
        pRepresentation: *mut AC_REPRESENTATION,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetUnit(acNode hNode, char* pUnitBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pUnitBuf\n  - Type: char*\n  - [Out] parameter\n  - Unit of the value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetValue </B> represents the units of the value."]
    pub fn acIntegerGetUnit(
        hNode: acNode,
        pUnitBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerGetValue(acNode hNode, int64_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerGetValue </B> retrieves the current value."]
    pub fn acIntegerGetValue(hNode: acNode, pValue: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerImposeMin(acNode hNode, int64_t imposedMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param imposedMinimum\n  - Type: int64_t\n  - [In] parameter\n  - Minimum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerImposeMin </B> imposes a minimum. New minimum must be greater\n than the actual minimum."]
    pub fn acIntegerImposeMin(hNode: acNode, imposedMinimum: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerImposeMax(acNode hNode, int64_t imposedMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param imposedMaximum\n  - Type: int64_t\n  - [In] parameter\n  - Maximum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerImposeMax </B> imposes a maximum. New maximum msut be less than\n the actual maximum."]
    pub fn acIntegerImposeMax(hNode: acNode, imposedMaximum: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acIntegerSetValue(acNode hNode, int64_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts integer nodes\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acIntegerSetValue </B> sets a new value."]
    pub fn acIntegerSetValue(hNode: acNode, value: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBooleanGetValue(acNode hNode, bool8_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts boolean nodes\n\n @param pValue\n  - Type: bool8_t*\n  - [Out] parameter\n  - Value of the node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBooleanGetValue </B> retrieves a boolean node's value."]
    pub fn acBooleanGetValue(hNode: acNode, pValue: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acBooleanSetValue(acNode hNode, bool8_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts boolean nodes\n\n @param value\n  - Type: bool8_t\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acBooleanSetValue </B> sets a boolean node's value."]
    pub fn acBooleanSetValue(hNode: acNode, value: bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCommandExecute(acNode hNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts command nodes\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCommandExecute </B> executes an action associated with the command node."]
    pub fn acCommandExecute(hNode: acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCommandIsDone(acNode hNode, bool8_t* pIsDone)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts command nodes\n\n @param pIsDone\n  - Type: bool8_t*\n  - [Out] parameter\n  - False if the action is currently processing\n  - Otherwise, true\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCommandIsDone </B> retrieves whether or not the execution of the node\n has completed."]
    pub fn acCommandIsDone(hNode: acNode, pIsDone: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatSetValue(acNode hNode, double value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param value\n  - Type: double\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatSetValue </B> sets a new value."]
    pub fn acFloatSetValue(hNode: acNode, value: f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetValue(acNode hNode, double* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Current value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetValue </B> retrieves the current value."]
    pub fn acFloatGetValue(hNode: acNode, pValue: *mut f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetMin(acNode hNode, double* pMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pMinimum\n  - Type: double*\n  - [Out] parameter\n  - Minimum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetMin </B> retrieves the minimum value."]
    pub fn acFloatGetMin(hNode: acNode, pMinimum: *mut f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetMax(acNode hNode, double* pMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pMaximum\n  - Type: double*\n  - [Out] parameter\n  - Maximum value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetMax </B> retrieves the maximum value."]
    pub fn acFloatGetMax(hNode: acNode, pMaximum: *mut f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatHasInc(acNode hNode, bool8_t* pHasInc)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pHasInc\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the value has a software-imposed increment\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatHasInc </B> retrieves whether or not the value has an increment."]
    pub fn acFloatHasInc(hNode: acNode, pHasInc: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetIncMode(acNode hNode, AC_INC_MODE* pIncMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pIncMode\n  - Type: AC_INC_MODE*\n  - [Out] parameter\n  - Increment mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetIncMode </B> retrieves the increment (if there is one)."]
    pub fn acFloatGetIncMode(hNode: acNode, pIncMode: *mut AC_INC_MODE) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetInc(acNode hNode, double* pIncrement)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pIncrement\n  - Type: double*\n  - [Out] parameter\n  - Increment value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetInc </B> retrieves the value increment (if there is one). Get\n the increment after checking whether there is one (acFloatHasInc).\n\n @see\n  - acFloatHasInc"]
    pub fn acFloatGetInc(hNode: acNode, pIncrement: *mut f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetRepresentation(acNode hNode, AC_REPRESENTATION* pRepresentation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pRepresentation\n  - Type: AC_REPRESENTATION*\n  - [Out] parameter\n  - Numeric representation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetRepresentation </B> retrieves the value representation."]
    pub fn acFloatGetRepresentation(
        hNode: acNode,
        pRepresentation: *mut AC_REPRESENTATION,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetUnit(acNode hNode, char* pUnitBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pUnitBuf\n  - Type: char*\n  - [Out] parameter\n  - Value unit\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetUnit </B> retrieves the units of the value."]
    pub fn acFloatGetUnit(
        hNode: acNode,
        pUnitBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetDisplayNotation(acNode hNode, AC_DISPLAY_NOTATION* pDisplayNotation)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pDisplayNotation\n  - Type: AC_DISPLAY_NOTATION*\n  - [Out] parameter\n  - Display notation\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetDisplayNotation </B> retrieves the best way to display the\n float, either by floating point, scientific notation, or both depending on the\n value (automatic)."]
    pub fn acFloatGetDisplayNotation(
        hNode: acNode,
        pDisplayNotation: *mut AC_DISPLAY_NOTATION,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatGetDisplayPrecision(acNode hNode, int64_t* pDisplayPrecision)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param pDisplayPrecision\n  - Type: int64_t*\n  - [Out] parameter\n  - Floating point precision\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatGetDisplayPrecision </B> retrieves the floating point precision of\n the value."]
    pub fn acFloatGetDisplayPrecision(hNode: acNode, pDisplayPrecision: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatImposeMin(acNode hNode, double imposedMinimum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param imposedMinimum\n  - Type: double\n  - [In] parameter\n  - Minimum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatImposeMin </B> imposes a minimum. New minimum must be greater than\n the actual minimum."]
    pub fn acFloatImposeMin(hNode: acNode, imposedMinimum: f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acFloatImposeMax(acNode hNode, double imposedMaximum)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts float nodes\n\n @param imposedMaximum\n  - Type: double\n  - [In] parameter\n  - Maximum to impose\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acFloatImposeMax </B> imposes a maximum. New maximum must be less than the\n actual maximum."]
    pub fn acFloatImposeMax(hNode: acNode, imposedMaximum: f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringSetValue(acNode hNode, const char* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pValue\n  - Type: const char*\n  - [In] parameter\n  - Value to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringSetValue </B> sets a new value. New value must be shorter than the\n maximum value length (acStringGetMaxLength).\n\n @see\n  - acStringGetMaxLength"]
    pub fn acStringSetValue(hNode: acNode, pValue: *const ::std::os::raw::c_char) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringGetValue(acNode hNode, char* pValue, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pValue\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Current value\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringGetValue </B> retrieves the current value of the node."]
    pub fn acStringGetValue(
        hNode: acNode,
        pValue: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acStringGetMaxLength(acNode hNode, int64_t* pMaxLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts string nodes\n\n @param pMaxLen\n  - Type: int64_t*\n  - [Out] parameter\n  - Maximum length\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acStringGetMaxLength </B> retrieves the maximum length of the value\n string."]
    pub fn acStringGetMaxLength(hNode: acNode, pMaxLen: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acRegisterSet(acNode hNode, const uint8_t* pBuf, int64_t bufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts register nodes\n\n @param pBuf\n  - Type: const uint8_t*\n  - [In] parameter\n  - Buffer with the value to set\n\n @param bufLen\n  - Type: int64_t\n  - [In] parameter\n  - Length of buffer to set\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acRegisterSet </B> sets a register node's value."]
    pub fn acRegisterSet(hNode: acNode, pBuf: *const u8, bufLen: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acRegisterGet(acNode hNode, uint8_t* pBuf, int64_t bufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts register nodes\n\n @param pBuf\n  - Type: uint8_t*\n  - [Out] parameter\n  - Empty buffer to get the value\n\n @param bufLen\n  - Type: int64_t\n  - [In] parameter\n  - Length of the buffer to get\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acRegisterGet </B> gets a register node's value."]
    pub fn acRegisterGet(hNode: acNode, pBuf: *mut u8, bufLen: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetNumFeatures(acNode hNode, size_t* pNumFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param pNumFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetNumFeatures </B> retrieves the number of features of a\n category node."]
    pub fn acCategoryGetNumFeatures(hNode: acNode, pNumFeatures: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetFeature(acNode hNode, size_t index, acNode* hFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the feature\n\n @param hFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Feature node (node of any type)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetFeatureAndAccessMode </B> retrieves a feature node by its\n index."]
    pub fn acCategoryGetFeature(hNode: acNode, index: usize, hFeatureNode: *mut acNode)
        -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acCategoryGetFeatureAndAccessMode(acNode hNode, size_t index, acNode* hFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts category nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the feature node\n\n @param hFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Feature node (node of any type)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Feature node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acCategoryGetFeatureAndAccessMode </B> retrieves a feature node and its\n access mode by its index."]
    pub fn acCategoryGetFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        hFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetNumEntries(acNode hNode, size_t* pNumEntries)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pNumEntries\n  - Type: size_t*\n  - [Out] parameter\n  - Number of entries\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetNumEntries </B> retrieves the number of entries."]
    pub fn acEnumerationGetNumEntries(hNode: acNode, pNumEntries: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryByIndex(acNode hNode, size_t index, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryByIndex </B> retrieves an entry by its index."]
    pub fn acEnumerationGetEntryByIndex(
        hNode: acNode,
        index: usize,
        phEntryNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryAndAccessModeByIndex(acNode hNode, size_t index, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryAndAccessModeByIndex </B> retrieves an entry and its\n access mode by index."]
    pub fn acEnumerationGetEntryAndAccessModeByIndex(
        hNode: acNode,
        index: usize,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetNumSymbolics(acNode hNode, size_t* pNumSymbolics)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pNumSymbolics\n  - Type: size_t*\n  - [Out] parameter\n  - Number of symbolics\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetNumSymbolics </B> retrieves the number of symbolics."]
    pub fn acEnumerationGetNumSymbolics(hNode: acNode, pNumSymbolics: *mut usize) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetSymbolicByIndex(acNode hNode, size_t index, char* pSymbolicBuf, size_t* pBufLen)\n\n )\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Entry of the node\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetSymbolicByIndex </B> retrieves a symbolic by its entry's\n index."]
    pub fn acEnumerationGetSymbolicByIndex(
        hNode: acNode,
        index: usize,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationSetByIntValue(acNode hNode, int64_t value)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param value\n  - Type: int64_t\n  - [In] parameter\n  - Integer value to set (from entry node)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationSetByIntValue </B> sets the entry by its integer value."]
    pub fn acEnumerationSetByIntValue(hNode: acNode, value: i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationSetBySymbolic(acNode hNode, const char* pSymbolic)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pSymbolic\n  - Type: const char*\n  - [In] parameter\n  - Symbolic to set (from entry node)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationSetBySymbolic </B> sets the entry of by its symbolic."]
    pub fn acEnumerationSetBySymbolic(
        hNode: acNode,
        pSymbolic: *const ::std::os::raw::c_char,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryByName(acNode hNode, const char* pEntryName, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pEntryName\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryByName </B> retrieves an entry by its name."]
    pub fn acEnumerationGetEntryByName(
        hNode: acNode,
        pEntryName: *const ::std::os::raw::c_char,
        phEntryNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetEntryAndAccessModeByName(acNode hNode, const char* pEntryName, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pEntryName\n  - Type: const char*\n  - [In] parameter\n  - Name of the entry\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetEntryAndAccessModeByName </B> retrieves an entry and its\n access mode by its name."]
    pub fn acEnumerationGetEntryAndAccessModeByName(
        hNode: acNode,
        pEntryName: *const ::std::os::raw::c_char,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentEntry(acNode hNode, acNode* phEntryNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Current entry node\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentEntry </B> retrieves the current entry."]
    pub fn acEnumerationGetCurrentEntry(hNode: acNode, phEntryNode: *mut acNode) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentEntryAndAccessMode(acNode hNode, acNode* phEntryNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param phEntryNode\n  - Type: acNode*\n  - [Out] parameter\n  - Current entry node\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Current entry node's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentEntryAndAccessMode </B> retrieves the current entry\n and its access mode."]
    pub fn acEnumerationGetCurrentEntryAndAccessMode(
        hNode: acNode,
        phEntryNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumerationGetCurrentSymbolic(acNode hNode, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enumeration nodes\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Accepts null\n  - Symbolic of the current entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumerationGetCurrentSymbolic </B> retrieves the current entry's\n symbolic."]
    pub fn acEnumerationGetCurrentSymbolic(
        hNode: acNode,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetIntValue(acNode hNode, int64_t* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pValue\n  - Type: int64_t*\n  - [Out] parameter\n  - Integer value of the entry\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetIntValue </B> retrieves the integer value of the enum entry."]
    pub fn acEnumEntryGetIntValue(hNode: acNode, pValue: *mut i64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetNumericValue(acNode hNode, double* pValue)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pValue\n  - Type: double*\n  - [Out] parameter\n  - Numeric value of the entry (if applicable)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetNumericValue </B> retrieves the numeric value of the enum\n entry (if applicable)."]
    pub fn acEnumEntryGetNumericValue(hNode: acNode, pValue: *mut f64) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryGetSymbolic(acNode hNode, char* pSymbolicBuf, size_t* pBufLen)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pSymbolicBuf\n  - Type: char*\n  - [Out] parameter\n  - Symbolic of the entry\n\n @param pBufLen\n  - Type: size_t*\n  - [In/out] parameter\n  - (In) Length of the buffer\n  - (Out) Length of the value\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryGetSymbolic </B> retrieves the symbolic of the enum entry."]
    pub fn acEnumEntryGetSymbolic(
        hNode: acNode,
        pSymbolicBuf: *mut ::std::os::raw::c_char,
        pBufLen: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acEnumEntryIsSelfClearing(acNode hNode, bool8_t* pIsSelfClearing)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts enum entry nodes\n\n @param pIsSelfClearing\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if the entry is self clearing\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acEnumEntryIsSelfClearing </B> retrieves whether or not the enum entry is\n self clearing."]
    pub fn acEnumEntryIsSelfClearing(hNode: acNode, pIsSelfClearing: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorIsSelector(acNode hNode, bool8_t* pIsSelector)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param pIsSelector\n  - Type: bool8_t*\n  - [Out] parameter\n  - True if node is a selector\n  - Otherwise, false\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves whether or not a node is a selector."]
    pub fn acSelectorIsSelector(hNode: acNode, pIsSelector: *mut bool8_t) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetNumSelectingFeatures(acNode hNode, size_t* pNumSelectingFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param pNumSelectingFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of selecting features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves the number of selecting features of a\n selector node."]
    pub fn acSelectorGetNumSelectingFeatures(
        hNode: acNode,
        pNumSelectingFeatures: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectingFeature(acNode hNode, size_t index, acNode* phSelectingFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selecting feature\n\n @param phSelectingFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selecting feature (node of type enum entry)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selecting feature by its index."]
    pub fn acSelectorGetSelectingFeature(
        hNode: acNode,
        index: usize,
        phSelectingFeatureNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectingFeatureAndAccessMode(acNode hNode, size_t index, acNode* phSelectingFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selecting feature\n\n @param phSelectingFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selecting feature (node of type enum entry)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Selecting feature's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selecting feature and its access\n mode by its index."]
    pub fn acSelectorGetSelectingFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        phSelectingFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetNumSelectedFeatures(acNode hNode, size_t* pNumSelectedFeatures)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector node\n\n @param pNumSelectedFeatures\n  - Type: size_t*\n  - [Out] parameter\n  - Number of selected features\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves the number of selected features of a\n selector node."]
    pub fn acSelectorGetNumSelectedFeatures(
        hNode: acNode,
        pNumSelectedFeatures: *mut usize,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectedFeature(acNode hNode, size_t index, acNode* phSelectedFeatureNode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of the selected feature\n\n @param phSelectedFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selected feature (node of type enum entry)\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selected feature by its index."]
    pub fn acSelectorGetSelectedFeature(
        hNode: acNode,
        index: usize,
        phSelectedFeatureNode: *mut acNode,
    ) -> AC_ERROR;
}
extern "C" {
    #[doc = " @fn AC_ERROR AC_API acSelectorGetSelectedFeatureAndAccessMode(acNode hNode, size_t index, acNode* phSelectedFeatureNode, AC_ACCESS_MODE* pAccessMode)\n\n @param hNode\n  - Type: acNode\n  - [In] parameter\n  - A node\n  - Accepts selector nodes\n\n @param index\n  - Type: size_t\n  - [In] parameter\n  - Index of selected feature\n\n @param phSelectedFeatureNode\n  - Type: acNode*\n  - [Out] parameter\n  - Selected feature (node of type enum entry)\n\n @param pAccessMode\n  - Type: AC_ACCESS_MODE*\n  - [Out] parameter\n  - Selected feature's access mode\n\n @return\n  - Type: AC_ERROR\n  - Error code for the function\n  - Returns AC_ERR_SUCCESS (0) on success\n\n <B> acSelectorIsSelector </B> retrieves a selected feature and its access mode\n by its index."]
    pub fn acSelectorGetSelectedFeatureAndAccessMode(
        hNode: acNode,
        index: usize,
        phSelectedFeatureNode: *mut acNode,
        pAccessMode: *mut AC_ACCESS_MODE,
    ) -> AC_ERROR;
}
